{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Liquidart Liquidart is an HTTP web server framework for building REST Applications written in Dart. We offer built-in support for PostgreSQL, a valuable open source database engine. This is a revival of the Aqueduct project, which was abandoned by the StableKernel team. They did a great job with the Aqueduct package, but reached a point where they can no longer support its active development. To download the latest version of the Liquidart package for Dart and Flutter, go to Liquidart on pub.dev How to Use this Documentation The menu on the left contains a hierarchy documents. Those documents - and how you should use them - are described in the following table: Location Description Recommended Usage Top-Level (e.g. Tour, Core Concepts) Introductory and quick reference documents Read these documents when you are new to Liquidart Snippets Example code snippets of common behaviors Read these documents for examples and inspiration Tutorial A linear, guided tutorial to building your first application A 1-3 hour long tutorial to learn Liquidart Guides A hierarchy of in-depth guides for the many facets of Liquidart Refer to these documents often to understand concepts and usage of Liquidart In addition to these guides, be sure to use the API Reference to look up classes, methods, functions and other elements of the framework. Getting Started Tips The best way to get started is to read the Core Concepts guide while working through the tutorial . Then, add new features to the application created during the tutorial by looking up the classes you are using in the API Reference , and implementing behavior not found in the tutorial. Once you have the basic concepts down, start reading the guides in the left hand menu to take advantage of the many features of the framework. Check out the repository of examples here. Import this file into IntelliJ IDEA for Liquidart file and code templates. Liquidart is catered towards test-driven development - the best way to write an application is to write tests using a test harness and run those tests after implementing an endpoint. You may also run the command liquidart document client in your project directory to generate a web client for your application. This client can be opened in any browser and will execute requests against your locally running application.","title":"Welcome"},{"location":"#welcome-to-liquidart","text":"Liquidart is an HTTP web server framework for building REST Applications written in Dart. We offer built-in support for PostgreSQL, a valuable open source database engine. This is a revival of the Aqueduct project, which was abandoned by the StableKernel team. They did a great job with the Aqueduct package, but reached a point where they can no longer support its active development. To download the latest version of the Liquidart package for Dart and Flutter, go to Liquidart on pub.dev","title":"Welcome to Liquidart"},{"location":"#how-to-use-this-documentation","text":"The menu on the left contains a hierarchy documents. Those documents - and how you should use them - are described in the following table: Location Description Recommended Usage Top-Level (e.g. Tour, Core Concepts) Introductory and quick reference documents Read these documents when you are new to Liquidart Snippets Example code snippets of common behaviors Read these documents for examples and inspiration Tutorial A linear, guided tutorial to building your first application A 1-3 hour long tutorial to learn Liquidart Guides A hierarchy of in-depth guides for the many facets of Liquidart Refer to these documents often to understand concepts and usage of Liquidart In addition to these guides, be sure to use the API Reference to look up classes, methods, functions and other elements of the framework.","title":"How to Use this Documentation"},{"location":"#getting-started-tips","text":"The best way to get started is to read the Core Concepts guide while working through the tutorial . Then, add new features to the application created during the tutorial by looking up the classes you are using in the API Reference , and implementing behavior not found in the tutorial. Once you have the basic concepts down, start reading the guides in the left hand menu to take advantage of the many features of the framework. Check out the repository of examples here. Import this file into IntelliJ IDEA for Liquidart file and code templates. Liquidart is catered towards test-driven development - the best way to write an application is to write tests using a test harness and run those tests after implementing an endpoint. You may also run the command liquidart document client in your project directory to generate a web client for your application. This client can be opened in any browser and will execute requests against your locally running application.","title":"Getting Started Tips"},{"location":"best_practices/","text":"Best Practices for Developing Liquidart Applications Keep Dart Projects Separate Because Dart is cross-platform, developers should avoid combining client application projects with Liquidart projects. Instead, use a single repository with an independent project for each facet of the system. When there are opportunities for code sharing between platforms (typically between Flutter and AngularDart), shared code can live in a dependency project in the same repository. A typical directory structure for an multi-faceted application looks like this: application_name/ liquidart/ flutter/ angular/ shared/ Project A project is a directory that contain a pubspec.yaml file and lib directory. It is tempting to share your data model types between your server and client applications, but this falls apart for anything but the most simple of applications. There are enough behavioral differences between the four representations of your data model - in the database, on the server, on the wire (JSON), and on the client - that a single type will have a hard time encompassing. Instead, generate an OpenAPI specification with liquidart document and use one of the many open-source tools for generating client data model types. Use Test Driven Development (or something close to it) In Liquidart, testing is a first-class citizen. The liquidart_test package has classes and methods for initializing and running an application for testing, making requests to that application, and verifying the responses. There is value to using tools like Postman or CURL to test proof of concept code, but the liquidart_test package is geared specifically for replacing these tools while retaining automated tests as the project grows. An example test suite looks like this: void main() { final harness = new Harness()..install(); test(\"GET /endpoint returns 200 and a simple object\", () async { final response = await harness.agent.get(\"/endpoint\"); expectResponse(response, 200, body: {\"key\": \"value\"}); }); } Use a bin Script to Verify Assumptions Keep a simple Dart script file in the bin/ directory that imports your project. Use this file as a scratchpad to test exploratory code before committing to a test suite. Don't check this file into source control. import 'package:myapp/myapp.dart'; Future main() async { var whatIsThis = await someYetToBeNamedUsefullyMethod(); print(\"$whatIsThis\"); } Create New Projects from a Template Use liquidart create to create applications with the appropriate structure and boilerplate. There are templates for different kinds of applications; view these templates with liquidart create list-templates . Use a Debugger A debugger allows you to stop execution of a running application at a particular line of code to verify variable values, and then continue to step through that code line by line. It can be used when running test suites or when running the application through the bin/main.dart script. In IntelliJ IDEA, right-click on any file with a main function (which includes test suites) and select Debug option. Use breakpoints (by clicking on the gutter area to the left of the text editing area) to stop execution at a particular line before it is executed. Use the Suggested Project Directory Structure See Liquidart Project Structure . Pass Services to Controllers in entryPoint Pass service objects to controllers in entryPoint and only pass the services the controller will use. class AppChannel extends ApplicationChannel { GitHub githubService; PostgreSQLConnection databaseConnection; @override Future prepare() async { databaseConnection = new PostgreSQLConnection(); githubService = new GitHub(); } @override Controller get entryPoint { final router = new Router(); router .route(\"/data\") .link(() => new DBController(databaseConnection)); router .route(\"/github\") .link(() => new GitHubController(githubService)); return router; } } Passing references like this allows for injecting dependencies that depend on the environment; e.g. in production, development or during tests. It also avoids tight coupling between the objects in your application. Minimize the access a controller has to its dependencies; e.g. don't pass it a StreamController when it only needs Sink or a Stream . Use a Test Harness A test harness initializes your application in a test suite. It has built in behavior that you can add to for things that are specific to your application. Documentation for using a test harness in your application is located here . Use config.src.yaml Use the convention of config.src.yaml file to prevent configuration errors and inject test dependencies. Understand how Liquidart Uses Isolates See more in Application Structure . Use ResourceController Subclasses Subclassing ResourceController provides significant conveniences, safeties and behaviors used by the majority of an application's request handling logic. Prefer to use this class for non-middleware controllers. Keep ApplicationChannel Tidy A ApplicationChannel should handle initialization, routing and nothing more. Consider moving non-initialization behavior into a service object in a separate file. Avoid Raw SQL Queries Prefer to use the Liquidart ORM. It sends appropriate HTTP responses for different kinds of errors, validates input data and is ensures the queries match up with your data model. Use API Reference Liquidart is an object oriented framework - behaviors are implemented by instances of some type. The types of objects, their properties and their behaviors all follow similar naming conventions to make the API more discoverable. Many types in Liquidart have a prefix in common with related types. For example, types like AuthServer , AuthServerDelegate and AuthCode are all related because they deal with authentication and authorization. Methods are named consistently across classes (e.g, asMap is a common method name). When looking for a solution, look at the API reference for the objects you have access to. These objects may already have the behavior you wish to implement or have a reference to an object with that behavior. Use try-catch Sparingly All request handling code is wrapped in a try-catch block that will interpret exceptions and errors and return meaningful HTTP responses. Unknown exceptions will yield a 500 Server Error response. In general, you do not need to use try-catch unless you want a different HTTP response than the one being returned for the exception. Code that throws an exception during initialization should not be caught if the error is fatal to the application launching successfully.","title":"Best Practices"},{"location":"best_practices/#best-practices-for-developing-liquidart-applications","text":"","title":"Best Practices for Developing Liquidart Applications"},{"location":"best_practices/#keep-dart-projects-separate","text":"Because Dart is cross-platform, developers should avoid combining client application projects with Liquidart projects. Instead, use a single repository with an independent project for each facet of the system. When there are opportunities for code sharing between platforms (typically between Flutter and AngularDart), shared code can live in a dependency project in the same repository. A typical directory structure for an multi-faceted application looks like this: application_name/ liquidart/ flutter/ angular/ shared/ Project A project is a directory that contain a pubspec.yaml file and lib directory. It is tempting to share your data model types between your server and client applications, but this falls apart for anything but the most simple of applications. There are enough behavioral differences between the four representations of your data model - in the database, on the server, on the wire (JSON), and on the client - that a single type will have a hard time encompassing. Instead, generate an OpenAPI specification with liquidart document and use one of the many open-source tools for generating client data model types.","title":"Keep Dart Projects Separate"},{"location":"best_practices/#use-test-driven-development-or-something-close-to-it","text":"In Liquidart, testing is a first-class citizen. The liquidart_test package has classes and methods for initializing and running an application for testing, making requests to that application, and verifying the responses. There is value to using tools like Postman or CURL to test proof of concept code, but the liquidart_test package is geared specifically for replacing these tools while retaining automated tests as the project grows. An example test suite looks like this: void main() { final harness = new Harness()..install(); test(\"GET /endpoint returns 200 and a simple object\", () async { final response = await harness.agent.get(\"/endpoint\"); expectResponse(response, 200, body: {\"key\": \"value\"}); }); }","title":"Use Test Driven Development (or something close to it)"},{"location":"best_practices/#use-a-bin-script-to-verify-assumptions","text":"Keep a simple Dart script file in the bin/ directory that imports your project. Use this file as a scratchpad to test exploratory code before committing to a test suite. Don't check this file into source control. import 'package:myapp/myapp.dart'; Future main() async { var whatIsThis = await someYetToBeNamedUsefullyMethod(); print(\"$whatIsThis\"); }","title":"Use a bin Script to Verify Assumptions"},{"location":"best_practices/#create-new-projects-from-a-template","text":"Use liquidart create to create applications with the appropriate structure and boilerplate. There are templates for different kinds of applications; view these templates with liquidart create list-templates .","title":"Create New Projects from a Template"},{"location":"best_practices/#use-a-debugger","text":"A debugger allows you to stop execution of a running application at a particular line of code to verify variable values, and then continue to step through that code line by line. It can be used when running test suites or when running the application through the bin/main.dart script. In IntelliJ IDEA, right-click on any file with a main function (which includes test suites) and select Debug option. Use breakpoints (by clicking on the gutter area to the left of the text editing area) to stop execution at a particular line before it is executed.","title":"Use a Debugger"},{"location":"best_practices/#use-the-suggested-project-directory-structure","text":"See Liquidart Project Structure .","title":"Use the Suggested Project Directory Structure"},{"location":"best_practices/#pass-services-to-controllers-in-entrypoint","text":"Pass service objects to controllers in entryPoint and only pass the services the controller will use. class AppChannel extends ApplicationChannel { GitHub githubService; PostgreSQLConnection databaseConnection; @override Future prepare() async { databaseConnection = new PostgreSQLConnection(); githubService = new GitHub(); } @override Controller get entryPoint { final router = new Router(); router .route(\"/data\") .link(() => new DBController(databaseConnection)); router .route(\"/github\") .link(() => new GitHubController(githubService)); return router; } } Passing references like this allows for injecting dependencies that depend on the environment; e.g. in production, development or during tests. It also avoids tight coupling between the objects in your application. Minimize the access a controller has to its dependencies; e.g. don't pass it a StreamController when it only needs Sink or a Stream .","title":"Pass Services to Controllers in entryPoint"},{"location":"best_practices/#use-a-test-harness","text":"A test harness initializes your application in a test suite. It has built in behavior that you can add to for things that are specific to your application. Documentation for using a test harness in your application is located here .","title":"Use a Test Harness"},{"location":"best_practices/#use-configsrcyaml","text":"Use the convention of config.src.yaml file to prevent configuration errors and inject test dependencies.","title":"Use config.src.yaml"},{"location":"best_practices/#understand-how-liquidart-uses-isolates","text":"See more in Application Structure .","title":"Understand how Liquidart Uses Isolates"},{"location":"best_practices/#use-resourcecontroller-subclasses","text":"Subclassing ResourceController provides significant conveniences, safeties and behaviors used by the majority of an application's request handling logic. Prefer to use this class for non-middleware controllers.","title":"Use ResourceController Subclasses"},{"location":"best_practices/#keep-applicationchannel-tidy","text":"A ApplicationChannel should handle initialization, routing and nothing more. Consider moving non-initialization behavior into a service object in a separate file.","title":"Keep ApplicationChannel Tidy"},{"location":"best_practices/#avoid-raw-sql-queries","text":"Prefer to use the Liquidart ORM. It sends appropriate HTTP responses for different kinds of errors, validates input data and is ensures the queries match up with your data model.","title":"Avoid Raw SQL Queries"},{"location":"best_practices/#use-api-reference","text":"Liquidart is an object oriented framework - behaviors are implemented by instances of some type. The types of objects, their properties and their behaviors all follow similar naming conventions to make the API more discoverable. Many types in Liquidart have a prefix in common with related types. For example, types like AuthServer , AuthServerDelegate and AuthCode are all related because they deal with authentication and authorization. Methods are named consistently across classes (e.g, asMap is a common method name). When looking for a solution, look at the API reference for the objects you have access to. These objects may already have the behavior you wish to implement or have a reference to an object with that behavior.","title":"Use API Reference"},{"location":"best_practices/#use-try-catch-sparingly","text":"All request handling code is wrapped in a try-catch block that will interpret exceptions and errors and return meaningful HTTP responses. Unknown exceptions will yield a 500 Server Error response. In general, you do not need to use try-catch unless you want a different HTTP response than the one being returned for the exception. Code that throws an exception during initialization should not be caught if the error is fatal to the application launching successfully.","title":"Use try-catch Sparingly"},{"location":"core_concepts/","text":"Core Concepts Resources Resources are the things your application exposes through its HTTP API. A resource can be anything - a user profile in an application, a temperature sensor in Antarctica, or a high score for a game. For example, the GitHub API exposes organization, repository, issue and pull request resources; a social network API has profiles, posts, and user relationships. Resources are organized into collections (e.g., all of the posts), for which individual resources within that collection can be uniquely identified (e.g., a single post). Requests are made to an application to retrieve the state of a resource or to provide the desired state of a resource. Most often, resources are represented as JSON arrays and objects. When retrieving a resource, its JSON representation is encoded into the response body. When providing the desired state of a resource, a client sends the JSON representation of the desired resource state in the request body. For more details on the concept of a resource, see the RFC Specification for HTTP/1.1 . Routing Resources are identified by the path of an HTTP request. For example, the URL http://example.com/organizations identifies the collection of organization resources on the server http://example.com . The URL http://example.com/organizations/1 identifies a single organization. An application exposes routes for each resource it manages. A route is a string that matches the path of a request. When a request's path matches a route, the associated handler is invoked to handle the request. Routes look like paths, but have some additional syntax. For example, the route /organizations will match requests with the path /organizations. The route /organizations/:id will match the paths /organizations/1 , /organizations/2 , and so on. Complex routes can be formed with additional syntax. See the guide on routing for usage details. Controllers Controllers are objects that handle requests. For example, a controller might fetch rows from a database and send them to the client in the response body. Another controller might verify the username and password of a request's Authorization header are valid. Controllers are linked together to form a series of actions to take for a request. These linked together controllers are called a channel. If the above examples were linked together, the channel would check if a request were authorized before it sent a response containing database rows. There are two flavors of controllers. An endpoint controller performs operations on a resource or resource collection, and always sends a response. Endpoint controllers fulfill requests by returning the state of a resource or by changing the state of a resource. You write most of your application-specific logic endpoint controllers. A middleware controller takes an action for a request, but isn't responsible for fulfilling the request. Middleware controllers can do many different things and are often reusable in many channels. Most often, a middleware controller validates something about a request before it reaches an endpoint controller. Middleware controllers can send a response for a request, and doing so prevents any other controller in that channel from handling the request. A channel must have exactly one endpoint controller. It can be preceded by zero or more middleware controllers. See the guides on Controllers and ResourceControllers for usage details. The Application Channel The application channel is an object that contains all of the controllers in an application. It designates one controller as the first controller to receive every request called its entry point. Controllers are linked to the entry point (directly or transitively) to form the entire application channel. In nearly every application, the entry point is a router; this controller splits the channel into sub-channels for a given route. The application channel is also responsible for initializing the application's services, reading configuration files and other startup related tasks. See the guide on the Application Channel for more details. Services A service is an object that encapsulates complex tasks or algorithms, external communication or tasks that will be reused across an application. The purpose of a service object is to provide a simple interface to more detailed behavior. For example, a database connection is a service object; a user of a database connection doesn't know the details of how the connection is made or how to encode the query onto the wire, but it can still execute queries. The primary user of service objects are controllers. Services are injected into controllers by passing them as arguments to the controller's constructor. The controller keeps a reference to the service, so that it can use it when handling a request. For more details on injecting services, see the guide on the Application Channel . Isolates Isolates are memory-isolated threads; an object created on one isolate can't be referenced by another isolate. When an application starts, one or more isolates containing replicas of your application code are spawned. This behavior effectively 'load balances' your application across multiple threads. A benefit to this structure is that each isolate has its own set of services, like database connections. This eliminates the need for techniques like 'database connection pooling', because the entire application is effectively 'pooled'. Bindings A request might contain headers, query parameters, a body and path parameters that need to be parsed, validated and used in controller code. Bindings are annotations added to variables that perform this parsing and validation automatically. Appropriate error responses are sent when a bound value can't be parsed into expected type or validation fails. Bindings cut down on boiler plate code and reduce testing surface, making development faster and code easier to reason about. For more information on bindings, see the guide on Resource Controllers . Queries and Data Models Application store information in databases for persistence. Writing database queries by hand is error-prone and doesn't leverage static analysis tools that are so valuable in a Dart application. Liquidart's ORM (Object-Relational Mapping) provides statically-typed queries that are easy to write and test. Your application's data model is defined by creating Dart classes. Each class is mapped to a database table, and each property of that class is mapped to a column in that table. Liquidart's command-line tool generates database migration files that detect changes in your data model that can be applied to a live, versioned database. A data model can also be represented as a JSON object to build tools on top of your application. For more details, see the guide on Databases . Authorization OAuth 2.0 is a standardized authorization framework. Liquidart contains a specification-compliant implementation of an OAuth 2.0 server that can be integrated directly into your application, or stood up alone to provide an authorization server for federated services. This implementation is easily customizable - it can store authorization artifacts - like tokens and client identifiers - in different types of databases or use stateless authorization mechanisms like JWT. The default implementation leverages the Liquidart ORM to store artifacts in PostgreSQL. For more details, see the guide on Authorization . Documentation OpenAPI 3.0 is a standardized documentation format for HTTP APIs. Many built-in Liquidart objects support 'automatic' documentation. Objects that are specific to your application can build on top of this to immediately document your application for every change you make. For more details, see the guide on OpenAPI Documentation .","title":"Core Concepts"},{"location":"core_concepts/#core-concepts","text":"","title":"Core Concepts"},{"location":"core_concepts/#resources","text":"Resources are the things your application exposes through its HTTP API. A resource can be anything - a user profile in an application, a temperature sensor in Antarctica, or a high score for a game. For example, the GitHub API exposes organization, repository, issue and pull request resources; a social network API has profiles, posts, and user relationships. Resources are organized into collections (e.g., all of the posts), for which individual resources within that collection can be uniquely identified (e.g., a single post). Requests are made to an application to retrieve the state of a resource or to provide the desired state of a resource. Most often, resources are represented as JSON arrays and objects. When retrieving a resource, its JSON representation is encoded into the response body. When providing the desired state of a resource, a client sends the JSON representation of the desired resource state in the request body. For more details on the concept of a resource, see the RFC Specification for HTTP/1.1 .","title":"Resources"},{"location":"core_concepts/#routing","text":"Resources are identified by the path of an HTTP request. For example, the URL http://example.com/organizations identifies the collection of organization resources on the server http://example.com . The URL http://example.com/organizations/1 identifies a single organization. An application exposes routes for each resource it manages. A route is a string that matches the path of a request. When a request's path matches a route, the associated handler is invoked to handle the request. Routes look like paths, but have some additional syntax. For example, the route /organizations will match requests with the path /organizations. The route /organizations/:id will match the paths /organizations/1 , /organizations/2 , and so on. Complex routes can be formed with additional syntax. See the guide on routing for usage details.","title":"Routing"},{"location":"core_concepts/#controllers","text":"Controllers are objects that handle requests. For example, a controller might fetch rows from a database and send them to the client in the response body. Another controller might verify the username and password of a request's Authorization header are valid. Controllers are linked together to form a series of actions to take for a request. These linked together controllers are called a channel. If the above examples were linked together, the channel would check if a request were authorized before it sent a response containing database rows. There are two flavors of controllers. An endpoint controller performs operations on a resource or resource collection, and always sends a response. Endpoint controllers fulfill requests by returning the state of a resource or by changing the state of a resource. You write most of your application-specific logic endpoint controllers. A middleware controller takes an action for a request, but isn't responsible for fulfilling the request. Middleware controllers can do many different things and are often reusable in many channels. Most often, a middleware controller validates something about a request before it reaches an endpoint controller. Middleware controllers can send a response for a request, and doing so prevents any other controller in that channel from handling the request. A channel must have exactly one endpoint controller. It can be preceded by zero or more middleware controllers. See the guides on Controllers and ResourceControllers for usage details.","title":"Controllers"},{"location":"core_concepts/#the-application-channel","text":"The application channel is an object that contains all of the controllers in an application. It designates one controller as the first controller to receive every request called its entry point. Controllers are linked to the entry point (directly or transitively) to form the entire application channel. In nearly every application, the entry point is a router; this controller splits the channel into sub-channels for a given route. The application channel is also responsible for initializing the application's services, reading configuration files and other startup related tasks. See the guide on the Application Channel for more details.","title":"The Application Channel"},{"location":"core_concepts/#services","text":"A service is an object that encapsulates complex tasks or algorithms, external communication or tasks that will be reused across an application. The purpose of a service object is to provide a simple interface to more detailed behavior. For example, a database connection is a service object; a user of a database connection doesn't know the details of how the connection is made or how to encode the query onto the wire, but it can still execute queries. The primary user of service objects are controllers. Services are injected into controllers by passing them as arguments to the controller's constructor. The controller keeps a reference to the service, so that it can use it when handling a request. For more details on injecting services, see the guide on the Application Channel .","title":"Services"},{"location":"core_concepts/#isolates","text":"Isolates are memory-isolated threads; an object created on one isolate can't be referenced by another isolate. When an application starts, one or more isolates containing replicas of your application code are spawned. This behavior effectively 'load balances' your application across multiple threads. A benefit to this structure is that each isolate has its own set of services, like database connections. This eliminates the need for techniques like 'database connection pooling', because the entire application is effectively 'pooled'.","title":"Isolates"},{"location":"core_concepts/#bindings","text":"A request might contain headers, query parameters, a body and path parameters that need to be parsed, validated and used in controller code. Bindings are annotations added to variables that perform this parsing and validation automatically. Appropriate error responses are sent when a bound value can't be parsed into expected type or validation fails. Bindings cut down on boiler plate code and reduce testing surface, making development faster and code easier to reason about. For more information on bindings, see the guide on Resource Controllers .","title":"Bindings"},{"location":"core_concepts/#queries-and-data-models","text":"Application store information in databases for persistence. Writing database queries by hand is error-prone and doesn't leverage static analysis tools that are so valuable in a Dart application. Liquidart's ORM (Object-Relational Mapping) provides statically-typed queries that are easy to write and test. Your application's data model is defined by creating Dart classes. Each class is mapped to a database table, and each property of that class is mapped to a column in that table. Liquidart's command-line tool generates database migration files that detect changes in your data model that can be applied to a live, versioned database. A data model can also be represented as a JSON object to build tools on top of your application. For more details, see the guide on Databases .","title":"Queries and Data Models"},{"location":"core_concepts/#authorization","text":"OAuth 2.0 is a standardized authorization framework. Liquidart contains a specification-compliant implementation of an OAuth 2.0 server that can be integrated directly into your application, or stood up alone to provide an authorization server for federated services. This implementation is easily customizable - it can store authorization artifacts - like tokens and client identifiers - in different types of databases or use stateless authorization mechanisms like JWT. The default implementation leverages the Liquidart ORM to store artifacts in PostgreSQL. For more details, see the guide on Authorization .","title":"Authorization"},{"location":"core_concepts/#documentation","text":"OpenAPI 3.0 is a standardized documentation format for HTTP APIs. Many built-in Liquidart objects support 'automatic' documentation. Objects that are specific to your application can build on top of this to immediately document your application for every change you make. For more details, see the guide on OpenAPI Documentation .","title":"Documentation"},{"location":"getting_started/","text":"Getting Started Installation Install Dart Activate the Liquidart CLI pub global activate liquidart Create a new project. liquidart create my_project Open the project directory in an IntelliJ IDE , Atom or Visual Studio Code . All three IDEs have a Dart plugin. How to learn Liquidart There are different approaches depending on how you prefer to learn. The guided tutorial is a hands-on walkthrough where you build an application while learning basic Liquidart concepts. The example repository contains a few deployable applications that you may review or tinker with. The guides (located in the menu on this website) dive deeply into the concepts of Liquidart and show example code. Creating a new project and using the API reference to jump right in. It is best to first understand how HTTP requests are responded to - the foundation of Liquidart - before moving on to topics such as the ORM and OAuth 2.0. Both the tutorial and the HTTP guides are the primary source of this information. A project created by the liquidart tool has example routes connected for modification, too. Creating a Project The liquidart create command-line tool creates new Liquidart project directories. The default template contains the minimal project structure for running an Liquidart application. A project name must be snake_case . liquidart create my_project_name Other templates exist that contain foundational code for using Liquidart's ORM and OAuth 2.0 implementation. These templates can be listed: liquidart create list-templates You may provide the name of a template when creating a project to use that template: liquidart create -t db my_project_name Using the Liquidart ORM Liquidart's ORM uses PostgreSQL . During development, you will need a locally running instance of PostgreSQL. On macOS, installing Postgres.app is a very convenient way to run PostgreSQL locally. For other platforms, see PostgreSQL's downloads page . When creating a project, use the db template. If adding to an existing project, see this guide. To create a database, make sure PostgreSQL is running and open the command-line utility to connect to it. psql Warning If you installed Postgres.app, psql is inside the application bundle. You can run this tool by selecting Open psql from the status bar item in the Finder. Then, create a database that your application will connect to and a user that it will connect with: CREATE DATABASE my_database_name; CREATE USER dart_app WITH PASSWORD 'dart'; GRANT ALL ON DATABASE my_database_name TO dart_app; An application must create a ManagedContext that handles the connection to this database: class MyChannel extends ApplicationChannel { ManagedContext context; @override Future prepare() async { var dataModel = new ManagedDataModel.fromCurrentMirrorSystem(); var store = new PostgreSQLPersistentStore.fromConnectionInfo( \"dart_app\", \"dart\", \"localhost\", 5432, \"my_database_name\"); context = new ManagedContext(dataModel, store); } ... } Once you have declared ManagedObjects in your application, generate the database schema by generating and executing migrations from your project's directory: liquidart db generate liquidart db upgrade --connect postgres://dart_app:dart@localhost:5432/my_database_name See the guides on connecting to a database and testing with a database for more details on configuring a database connection.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#installation","text":"Install Dart Activate the Liquidart CLI pub global activate liquidart Create a new project. liquidart create my_project Open the project directory in an IntelliJ IDE , Atom or Visual Studio Code . All three IDEs have a Dart plugin.","title":"Installation"},{"location":"getting_started/#how-to-learn-liquidart","text":"There are different approaches depending on how you prefer to learn. The guided tutorial is a hands-on walkthrough where you build an application while learning basic Liquidart concepts. The example repository contains a few deployable applications that you may review or tinker with. The guides (located in the menu on this website) dive deeply into the concepts of Liquidart and show example code. Creating a new project and using the API reference to jump right in. It is best to first understand how HTTP requests are responded to - the foundation of Liquidart - before moving on to topics such as the ORM and OAuth 2.0. Both the tutorial and the HTTP guides are the primary source of this information. A project created by the liquidart tool has example routes connected for modification, too.","title":"How to learn Liquidart"},{"location":"getting_started/#creating-a-project","text":"The liquidart create command-line tool creates new Liquidart project directories. The default template contains the minimal project structure for running an Liquidart application. A project name must be snake_case . liquidart create my_project_name Other templates exist that contain foundational code for using Liquidart's ORM and OAuth 2.0 implementation. These templates can be listed: liquidart create list-templates You may provide the name of a template when creating a project to use that template: liquidart create -t db my_project_name","title":"Creating a Project"},{"location":"getting_started/#using-the-liquidart-orm","text":"Liquidart's ORM uses PostgreSQL . During development, you will need a locally running instance of PostgreSQL. On macOS, installing Postgres.app is a very convenient way to run PostgreSQL locally. For other platforms, see PostgreSQL's downloads page . When creating a project, use the db template. If adding to an existing project, see this guide. To create a database, make sure PostgreSQL is running and open the command-line utility to connect to it. psql Warning If you installed Postgres.app, psql is inside the application bundle. You can run this tool by selecting Open psql from the status bar item in the Finder. Then, create a database that your application will connect to and a user that it will connect with: CREATE DATABASE my_database_name; CREATE USER dart_app WITH PASSWORD 'dart'; GRANT ALL ON DATABASE my_database_name TO dart_app; An application must create a ManagedContext that handles the connection to this database: class MyChannel extends ApplicationChannel { ManagedContext context; @override Future prepare() async { var dataModel = new ManagedDataModel.fromCurrentMirrorSystem(); var store = new PostgreSQLPersistentStore.fromConnectionInfo( \"dart_app\", \"dart\", \"localhost\", 5432, \"my_database_name\"); context = new ManagedContext(dataModel, store); } ... } Once you have declared ManagedObjects in your application, generate the database schema by generating and executing migrations from your project's directory: liquidart db generate liquidart db upgrade --connect postgres://dart_app:dart@localhost:5432/my_database_name See the guides on connecting to a database and testing with a database for more details on configuring a database connection.","title":"Using the Liquidart ORM"},{"location":"intellij/","text":"Liquidart IntelliJ IDEA Templates This document describes how to install file and code templates for Liquidart when using an IntelliJ IDE (e.g., IDEA, IDEA CE, Webstorm). Installation Download the this file and import it into IntelliJ by selecting Import Settings ... from the File menu. File Templates File templates are created by selecting New from the File menu or by right-clicking a directory in the project navigator. The following templates exists: Template Name Behavior Liquidart ResourceController Creates a new file with the skeleton of an ResourceController . Liquidart ManagedObject Creates a new file with the skeleton of a ManagedObject subclass Liquidart Test Creates a new file that creates and installs a TestHarness subclass from your project. Live Templates Live templates are keywords that expand into a larger code block. Typing the keyword in a Dart file and hitting return will enter common Liquidart code. Live templates often have placeholders that can by jumped between by using the return key. Live Template: HTTP Shortcut Behavior operation Creates a new operation method in a ResourceController . bindbody Adds a body binding to an operation method. bindheader Adds a header binding to an operation method. bindquery Adds a query binding to an operation method. bindpath Adds a path binding to an operation method. Live Template: ORM Shortcut Behavior ps Enters the property selector syntax for Query.where , Query.join and other query configuration methods. column Adds a column annotated field to a ManagedObject . relate Adds a relationship annotated field to a ManagedObject . Live Template: Testing Shortcut Behavior test Creates a test closure in a test file.","title":"IntelliJ IDEA Templates"},{"location":"intellij/#liquidart-intellij-idea-templates","text":"This document describes how to install file and code templates for Liquidart when using an IntelliJ IDE (e.g., IDEA, IDEA CE, Webstorm).","title":"Liquidart IntelliJ IDEA Templates"},{"location":"intellij/#installation","text":"Download the this file and import it into IntelliJ by selecting Import Settings ... from the File menu.","title":"Installation"},{"location":"intellij/#file-templates","text":"File templates are created by selecting New from the File menu or by right-clicking a directory in the project navigator. The following templates exists: Template Name Behavior Liquidart ResourceController Creates a new file with the skeleton of an ResourceController . Liquidart ManagedObject Creates a new file with the skeleton of a ManagedObject subclass Liquidart Test Creates a new file that creates and installs a TestHarness subclass from your project.","title":"File Templates"},{"location":"intellij/#live-templates","text":"Live templates are keywords that expand into a larger code block. Typing the keyword in a Dart file and hitting return will enter common Liquidart code. Live templates often have placeholders that can by jumped between by using the return key.","title":"Live Templates"},{"location":"intellij/#live-template-http","text":"Shortcut Behavior operation Creates a new operation method in a ResourceController . bindbody Adds a body binding to an operation method. bindheader Adds a header binding to an operation method. bindquery Adds a query binding to an operation method. bindpath Adds a path binding to an operation method.","title":"Live Template: HTTP"},{"location":"intellij/#live-template-orm","text":"Shortcut Behavior ps Enters the property selector syntax for Query.where , Query.join and other query configuration methods. column Adds a column annotated field to a ManagedObject . relate Adds a relationship annotated field to a ManagedObject .","title":"Live Template: ORM"},{"location":"intellij/#live-template-testing","text":"Shortcut Behavior test Creates a test closure in a test file.","title":"Live Template: Testing"},{"location":"tour/","text":"Liquidart: A Complete Tour The tour demonstrates many of Liquidart's features. Command-Line Interface (CLI) The liquidart command line tool creates, runs and documents Liquidart applications; manages database migrations; and manages OAuth client identifiers. Install by running pub global activate liquidart on a machine with Dart installed. Create and run an application: liquidart create my_app cd my_app/ liquidart serve Initialization An Liquidart application starts at an ApplicationChannel . You subclass it once per application to handle initialization tasks like setting up routes and database connections. An example application looks like this: import 'package:liquidart/liquidart.dart'; class TodoApp extends ApplicationChannel { ManagedContext context; @override Future prepare() async { context = ManagedContext(...); } @override Controller get entryPoint { final router = Router(); router .route(\"/projects/[:id]\") .link(() => ProjectController(context)); return router; } } Routing A router determines which controller object should handle a request. The route specification syntax is a concise syntax to construct routes with variables and optional segments in a single statement. @override Controller get entryPoint { final router = Router(); // Handles /users, /users/1, /users/2, etc. router .route(\"/projects/[:id]\") .link(() => ProjectController()); // Handles any route that starts with /file/ router .route(\"/file/*\") .link(() => FileController()); // Handles the specific route /health router .route(\"/health\") .linkFunction((req) async => Response.ok(null)); return router; } Controllers Controllers handle requests. A controller handles a request by overriding its handle method. This method either returns a response or a request. If a response is returned, that response is sent to the client. If the request is returned, the linked controller handles the request. class SecretKeyAuthorizer extends Controller { @override Future<RequestOrResponse> handle(Request request) async { if (request.raw.headers.value(\"x-secret-key\") == \"secret!\") { return request; } return Response.badRequest(); } } This behavior allows for middleware controllers to be linked together, such that a request goes through a number of steps before it is finally handled. All controllers execute their code in an exception handler. If an exception is thrown in your controller code, a response with an appropriate error code is returned. You subclass HandlerException to provide error response customization for application-specific exceptions. ResourceControllers ResourceControllers are the most often used controller. Each operation - e.g. POST /projects , GET /projects and GET /projects/1 - is mapped to methods in a subclass. Parameters of those methods are annotated to bind the values of the request when the method is invoked. import 'package:liquidart/liquidart.dart' class ProjectController extends ResourceController { @Operation.get('id') Future<Response> getProjectById(@Bind.path(\"id\") int id) async { // GET /projects/:id return Response.ok(...); } @Operation.post() Future<Response> createProject(@Bind.body() Project project) async { // POST /project final inserted = await insertProject(project); return Response.ok(inserted); } @Operation.get() Future<Response> getAllProjects( @Bind.header(\"x-client-id\") String clientId, {@Bind.query(\"limit\") int limit: 10}) async { // GET /projects return Response.ok(...); } } ManagedObjectControllers ManagedObjectController<T> s are ResourceControllers that automatically map a REST interface to database queries; e.g. POST inserts a row, GET gets all row of a type. They do not need to be subclassed, but can be to provide customization. router .route(\"/users/[:id]\") .link(() => ManagedObjectController<Project>(context)); Configuration An application's configuration is written in a YAML file. Each environment your application runs in (e.g., locally, under test, production, development) has different values for things like the port to listen on and database connection credentials. The format of a configuration file is defined by your application. An example looks like: // config.yaml database: host: api.projects.com port: 5432 databaseName: project port: 8000 Subclass Configuration and declare a property for each key in your configuration file: class TodoConfig extends Configuration { TodoConfig(String path) : super.fromFile(File(path)); DatabaseConfiguration database; int port; } The default name of your configuration file is config.yaml , but can be changed at the command-line. You create an instance of your configuration from the configuration file path from your application options: import 'package:liquidart/liquidart.dart'; class TodoApp extends ApplicationChannel { @override Future prepare() async { var options = TodoConfig(options.configurationFilePath); ... } } Running and Concurrency Liquidart applications are run with the liquidart serve command line tool. You can attach debugging and instrumentation tools and specify how many threads the application should run on: liquidart serve --observe --isolates 5 --port 8888 Liquidart applications are multi-isolate (multi-threaded). Each isolate runs a replica of the same web server with its own set of services like database connections. This makes behavior like database connection pooling implicit. PostgreSQL ORM The Query<T> class configures and executes database queries. Its type argument determines what table is to be queried and the type of object you will work with in your code. import 'package:liquidart/liquidart.dart' class ProjectController extends ResourceController { ProjectController(this.context); final ManagedContext context; @Operation.get() Future<Response> getAllProjects() async { final query = Query<Project>(context); final results = await query.fetch(); return Response.ok(results); } } Configuration of the query - like its WHERE clause - are configured through a fluent, type-safe syntax. A property selector identifies which column of the table to apply an expression to. The following query fetches all project's due in the next week and includes their tasks by joining the related table. final nextWeek = DateTime.now().add(Duration(days: 7)); final query = Query<Project>(context) ..where((project) => project.dueDate).isLessThan(nextWeek) ..join(set: (project) => project.tasks); final projects = await query.fetch(); Rows are inserted or updated by setting the statically-typed values of a query. final insertQuery = Query<Project>(context) ..values.name = \"Build an liquidart\" ..values.dueDate = DateTime(year, month); var newProject = await insertQuery.insert(); final updateQuery = Query<Project>(context) ..where((project) => project.id).equalTo(newProject.id) ..values.name = \"Build a miniature liquidart\"; newProject = await updateQuery.updateOne(); Query<T> s can perform sorting, joining and paging queries. final overdueQuery = Query<Project>(context) ..where((project) => project.dueDate).lessThan(DateTime().now()) ..sortBy((project) => project.dueDate, QuerySortOrder.ascending) ..join(object: (project) => project.owner); final overdueProjectsAndTheirOwners = await query.fetch(); Controllers will interpret exceptions thrown by queries to return an appropriate error response to the client. For example, unique constraint conflicts return 409, missing required properties return 400 and database connection failure returns 503. Defining a Data Model To use the ORM, you declare your tables as Dart types and create a subclass of ManagedObject<T> . A subclass maps to a table in the database, each instance maps to a row, and each property is a column. The following declaration will map to a table named _project with columns id , name and dueDate . class Project extends ManagedObject<_Project> implements _Project { bool get isPastDue => dueDate.difference(DateTime.now()).inSeconds < 0; } class _Project { @primaryKey int id; @Column(indexed: true) String name; DateTime dueDate; } Managed objects have relationships to other managed objects. Relationships can be has-one, has-many and many-to-many. A relationship is always two-sided - the related types must declare a property that references each other. class Project extends ManagedObject<_Project> implements _Project {} class _Project { ... // Project has-many Tasks ManagedSet<Task> tasks; } class Task extends ManagedObject<_Task> implements _Task {} class _Task { ... // Task belongs to a project, maps to 'project_id' foreign key column @Relate(#tasks) Project project; } ManagedObject<T> s are serializable and can be directly read from a request body, or encoded as a response body. class ProjectController extends ResourceController { @Operation.put('id') Future<Response> updateProject(@Bind.path('id') int projectId, @Bind.body() Project project) async { final query = Query<Project>(context) ..where((project) => project.id).equalTo(projectId) ..values = project; return Response.ok(await query.updateOne()); } } Database Migrations The CLI will automatically generate database migration scripts by detecting changes to your managed objects. The following, when ran in a project directory, will generate and execute a database migration. liquidart db generate liquidart db upgrade --connect postgres://user:password@host:5432/database You can edit migration files by hand to alter any assumptions or enter required values, and run liquidart db validate to ensure the changes still yield the same schema. Be sure to keep generated files in version control. OAuth 2.0 An OAuth 2.0 server implementation handles authentication and authorization for Liquidart applications. You create an AuthServer and its delegate as services in your application. The delegate is configurable and manages how tokens are generated and stored. By default, access tokens are a random 32-byte string and client identifiers, tokens and access codes are stored in your database using the ORM. import 'package:liquidart/liquidart.dart'; import 'package:liquidart/managed_auth.dart'; class AppApplicationChannel extends ApplicationChannel { AuthServer authServer; ManagedContext context; @override Future prepare() async { context = ManagedContext(...); final delegate = ManagedAuthDelegate<User>(context); authServer = AuthServer(delegate); } } Built-in authentication controllers for exchanging user credentials for access tokens are named AuthController and AuthCodeController . Authorizer s are middleware that require a valid access token to access their linked controller. Controller get entryPoint { final router = Router(); // POST /auth/token with username and password (or access code) to get access token router .route(\"/auth/token\") .link(() => AuthController(authServer)); // GET /auth/code returns login form, POST /auth/code grants access code router .route(\"/auth/code\") .link(() => AuthCodeController(authServer)); // ProjectController requires request to include access token router .route(\"/projects/[:id]\") .link(() => Authorizer.bearer(authServer)) .link(() => ProjectController(context)); return router; } The CLI has tools to manage OAuth 2.0 client identifiers and access scopes. liquidart auth add-client \\ --id com.app.mobile \\ --secret foobar \\ --redirect-uri https://somewhereoutthere.com \\ --allowed-scopes \"users projects admin.readonly\" Logging All requests are logged to an application-wide logger. Set up a listener for the logger in ApplicationChannel to write log messages to the console or another medium. class WildfireChannel extends ApplicationChannel { @override Future prepare() async { logger.onRecord.listen((record) { print(\"$record\"); }); } } Testing Liquidart tests start a local version of your application and execute requests. You write expectations on the responses. A TestHarness manages the starting and stopping of an application, and exposes a default Agent for executing requests. An Agent can be configured to have default headers, and multiple agents can be used within the same test. import 'harness/app.dart'; void main() { final harness = TestHarness<TodoApp>()..install(); test(\"GET /projects returns all projects\" , () async { var response = await harness.agent.get(\"/projects\"); expectResponse(response, 200, body: every(partial({ \"id\": greaterThan(0), \"name\": isNotNull, \"dueDate\": isNotNull }))); }); } Testing with a Database Liquidart's ORM uses PostgreSQL as its database. Before your tests run, Liquidart will create your application's database tables in a local PostgreSQL database. After the tests complete, it will delete those tables. This allows you to start with an empty database for each test suite as well as control exactly which records are in your database while testing, but without having to manage database schemas or use an mock implementation (e.g., SQLite). This behavior, and behavior for managing applications with an OAuth 2.0 provider, are available as harness mixins . Documentation OpenAPI documents describe your application's interface. These documents can be used to generate documentation and client code. A document can be generated by reflecting on your application's codebase, just run the liquidart document command. The liquidart document client command creates a web page that can be used to configure issue requests specific to your application.","title":"Tour"},{"location":"tour/#liquidart-a-complete-tour","text":"The tour demonstrates many of Liquidart's features.","title":"Liquidart: A Complete Tour"},{"location":"tour/#command-line-interface-cli","text":"The liquidart command line tool creates, runs and documents Liquidart applications; manages database migrations; and manages OAuth client identifiers. Install by running pub global activate liquidart on a machine with Dart installed. Create and run an application: liquidart create my_app cd my_app/ liquidart serve","title":"Command-Line Interface (CLI)"},{"location":"tour/#initialization","text":"An Liquidart application starts at an ApplicationChannel . You subclass it once per application to handle initialization tasks like setting up routes and database connections. An example application looks like this: import 'package:liquidart/liquidart.dart'; class TodoApp extends ApplicationChannel { ManagedContext context; @override Future prepare() async { context = ManagedContext(...); } @override Controller get entryPoint { final router = Router(); router .route(\"/projects/[:id]\") .link(() => ProjectController(context)); return router; } }","title":"Initialization"},{"location":"tour/#routing","text":"A router determines which controller object should handle a request. The route specification syntax is a concise syntax to construct routes with variables and optional segments in a single statement. @override Controller get entryPoint { final router = Router(); // Handles /users, /users/1, /users/2, etc. router .route(\"/projects/[:id]\") .link(() => ProjectController()); // Handles any route that starts with /file/ router .route(\"/file/*\") .link(() => FileController()); // Handles the specific route /health router .route(\"/health\") .linkFunction((req) async => Response.ok(null)); return router; }","title":"Routing"},{"location":"tour/#controllers","text":"Controllers handle requests. A controller handles a request by overriding its handle method. This method either returns a response or a request. If a response is returned, that response is sent to the client. If the request is returned, the linked controller handles the request. class SecretKeyAuthorizer extends Controller { @override Future<RequestOrResponse> handle(Request request) async { if (request.raw.headers.value(\"x-secret-key\") == \"secret!\") { return request; } return Response.badRequest(); } } This behavior allows for middleware controllers to be linked together, such that a request goes through a number of steps before it is finally handled. All controllers execute their code in an exception handler. If an exception is thrown in your controller code, a response with an appropriate error code is returned. You subclass HandlerException to provide error response customization for application-specific exceptions.","title":"Controllers"},{"location":"tour/#resourcecontrollers","text":"ResourceControllers are the most often used controller. Each operation - e.g. POST /projects , GET /projects and GET /projects/1 - is mapped to methods in a subclass. Parameters of those methods are annotated to bind the values of the request when the method is invoked. import 'package:liquidart/liquidart.dart' class ProjectController extends ResourceController { @Operation.get('id') Future<Response> getProjectById(@Bind.path(\"id\") int id) async { // GET /projects/:id return Response.ok(...); } @Operation.post() Future<Response> createProject(@Bind.body() Project project) async { // POST /project final inserted = await insertProject(project); return Response.ok(inserted); } @Operation.get() Future<Response> getAllProjects( @Bind.header(\"x-client-id\") String clientId, {@Bind.query(\"limit\") int limit: 10}) async { // GET /projects return Response.ok(...); } }","title":"ResourceControllers"},{"location":"tour/#managedobjectcontrollers","text":"ManagedObjectController<T> s are ResourceControllers that automatically map a REST interface to database queries; e.g. POST inserts a row, GET gets all row of a type. They do not need to be subclassed, but can be to provide customization. router .route(\"/users/[:id]\") .link(() => ManagedObjectController<Project>(context));","title":"ManagedObjectControllers"},{"location":"tour/#configuration","text":"An application's configuration is written in a YAML file. Each environment your application runs in (e.g., locally, under test, production, development) has different values for things like the port to listen on and database connection credentials. The format of a configuration file is defined by your application. An example looks like: // config.yaml database: host: api.projects.com port: 5432 databaseName: project port: 8000 Subclass Configuration and declare a property for each key in your configuration file: class TodoConfig extends Configuration { TodoConfig(String path) : super.fromFile(File(path)); DatabaseConfiguration database; int port; } The default name of your configuration file is config.yaml , but can be changed at the command-line. You create an instance of your configuration from the configuration file path from your application options: import 'package:liquidart/liquidart.dart'; class TodoApp extends ApplicationChannel { @override Future prepare() async { var options = TodoConfig(options.configurationFilePath); ... } }","title":"Configuration"},{"location":"tour/#running-and-concurrency","text":"Liquidart applications are run with the liquidart serve command line tool. You can attach debugging and instrumentation tools and specify how many threads the application should run on: liquidart serve --observe --isolates 5 --port 8888 Liquidart applications are multi-isolate (multi-threaded). Each isolate runs a replica of the same web server with its own set of services like database connections. This makes behavior like database connection pooling implicit.","title":"Running and Concurrency"},{"location":"tour/#postgresql-orm","text":"The Query<T> class configures and executes database queries. Its type argument determines what table is to be queried and the type of object you will work with in your code. import 'package:liquidart/liquidart.dart' class ProjectController extends ResourceController { ProjectController(this.context); final ManagedContext context; @Operation.get() Future<Response> getAllProjects() async { final query = Query<Project>(context); final results = await query.fetch(); return Response.ok(results); } } Configuration of the query - like its WHERE clause - are configured through a fluent, type-safe syntax. A property selector identifies which column of the table to apply an expression to. The following query fetches all project's due in the next week and includes their tasks by joining the related table. final nextWeek = DateTime.now().add(Duration(days: 7)); final query = Query<Project>(context) ..where((project) => project.dueDate).isLessThan(nextWeek) ..join(set: (project) => project.tasks); final projects = await query.fetch(); Rows are inserted or updated by setting the statically-typed values of a query. final insertQuery = Query<Project>(context) ..values.name = \"Build an liquidart\" ..values.dueDate = DateTime(year, month); var newProject = await insertQuery.insert(); final updateQuery = Query<Project>(context) ..where((project) => project.id).equalTo(newProject.id) ..values.name = \"Build a miniature liquidart\"; newProject = await updateQuery.updateOne(); Query<T> s can perform sorting, joining and paging queries. final overdueQuery = Query<Project>(context) ..where((project) => project.dueDate).lessThan(DateTime().now()) ..sortBy((project) => project.dueDate, QuerySortOrder.ascending) ..join(object: (project) => project.owner); final overdueProjectsAndTheirOwners = await query.fetch(); Controllers will interpret exceptions thrown by queries to return an appropriate error response to the client. For example, unique constraint conflicts return 409, missing required properties return 400 and database connection failure returns 503.","title":"PostgreSQL ORM"},{"location":"tour/#defining-a-data-model","text":"To use the ORM, you declare your tables as Dart types and create a subclass of ManagedObject<T> . A subclass maps to a table in the database, each instance maps to a row, and each property is a column. The following declaration will map to a table named _project with columns id , name and dueDate . class Project extends ManagedObject<_Project> implements _Project { bool get isPastDue => dueDate.difference(DateTime.now()).inSeconds < 0; } class _Project { @primaryKey int id; @Column(indexed: true) String name; DateTime dueDate; } Managed objects have relationships to other managed objects. Relationships can be has-one, has-many and many-to-many. A relationship is always two-sided - the related types must declare a property that references each other. class Project extends ManagedObject<_Project> implements _Project {} class _Project { ... // Project has-many Tasks ManagedSet<Task> tasks; } class Task extends ManagedObject<_Task> implements _Task {} class _Task { ... // Task belongs to a project, maps to 'project_id' foreign key column @Relate(#tasks) Project project; } ManagedObject<T> s are serializable and can be directly read from a request body, or encoded as a response body. class ProjectController extends ResourceController { @Operation.put('id') Future<Response> updateProject(@Bind.path('id') int projectId, @Bind.body() Project project) async { final query = Query<Project>(context) ..where((project) => project.id).equalTo(projectId) ..values = project; return Response.ok(await query.updateOne()); } }","title":"Defining a Data Model"},{"location":"tour/#database-migrations","text":"The CLI will automatically generate database migration scripts by detecting changes to your managed objects. The following, when ran in a project directory, will generate and execute a database migration. liquidart db generate liquidart db upgrade --connect postgres://user:password@host:5432/database You can edit migration files by hand to alter any assumptions or enter required values, and run liquidart db validate to ensure the changes still yield the same schema. Be sure to keep generated files in version control.","title":"Database Migrations"},{"location":"tour/#oauth-20","text":"An OAuth 2.0 server implementation handles authentication and authorization for Liquidart applications. You create an AuthServer and its delegate as services in your application. The delegate is configurable and manages how tokens are generated and stored. By default, access tokens are a random 32-byte string and client identifiers, tokens and access codes are stored in your database using the ORM. import 'package:liquidart/liquidart.dart'; import 'package:liquidart/managed_auth.dart'; class AppApplicationChannel extends ApplicationChannel { AuthServer authServer; ManagedContext context; @override Future prepare() async { context = ManagedContext(...); final delegate = ManagedAuthDelegate<User>(context); authServer = AuthServer(delegate); } } Built-in authentication controllers for exchanging user credentials for access tokens are named AuthController and AuthCodeController . Authorizer s are middleware that require a valid access token to access their linked controller. Controller get entryPoint { final router = Router(); // POST /auth/token with username and password (or access code) to get access token router .route(\"/auth/token\") .link(() => AuthController(authServer)); // GET /auth/code returns login form, POST /auth/code grants access code router .route(\"/auth/code\") .link(() => AuthCodeController(authServer)); // ProjectController requires request to include access token router .route(\"/projects/[:id]\") .link(() => Authorizer.bearer(authServer)) .link(() => ProjectController(context)); return router; } The CLI has tools to manage OAuth 2.0 client identifiers and access scopes. liquidart auth add-client \\ --id com.app.mobile \\ --secret foobar \\ --redirect-uri https://somewhereoutthere.com \\ --allowed-scopes \"users projects admin.readonly\"","title":"OAuth 2.0"},{"location":"tour/#logging","text":"All requests are logged to an application-wide logger. Set up a listener for the logger in ApplicationChannel to write log messages to the console or another medium. class WildfireChannel extends ApplicationChannel { @override Future prepare() async { logger.onRecord.listen((record) { print(\"$record\"); }); } }","title":"Logging"},{"location":"tour/#testing","text":"Liquidart tests start a local version of your application and execute requests. You write expectations on the responses. A TestHarness manages the starting and stopping of an application, and exposes a default Agent for executing requests. An Agent can be configured to have default headers, and multiple agents can be used within the same test. import 'harness/app.dart'; void main() { final harness = TestHarness<TodoApp>()..install(); test(\"GET /projects returns all projects\" , () async { var response = await harness.agent.get(\"/projects\"); expectResponse(response, 200, body: every(partial({ \"id\": greaterThan(0), \"name\": isNotNull, \"dueDate\": isNotNull }))); }); }","title":"Testing"},{"location":"tour/#testing-with-a-database","text":"Liquidart's ORM uses PostgreSQL as its database. Before your tests run, Liquidart will create your application's database tables in a local PostgreSQL database. After the tests complete, it will delete those tables. This allows you to start with an empty database for each test suite as well as control exactly which records are in your database while testing, but without having to manage database schemas or use an mock implementation (e.g., SQLite). This behavior, and behavior for managing applications with an OAuth 2.0 provider, are available as harness mixins .","title":"Testing with a Database"},{"location":"tour/#documentation","text":"OpenAPI documents describe your application's interface. These documents can be used to generate documentation and client code. A document can be generated by reflecting on your application's codebase, just run the liquidart document command. The liquidart document client command creates a web page that can be used to configure issue requests specific to your application.","title":"Documentation"},{"location":"tutorial/executing_queries/","text":"2. Reading from a Database We will continue to build on the last chapter's project, heroes , by storing our heroes in a database. This will let us to edit our heroes and keep the changes when we restart the application. Object-Relational Mapping A relational database management system (like PostgreSQL or MySQL) stores its data in the form of tables. A table represents some sort of entity - like a person or a bank account. Each table has columns that describe the attributes of that entity - like a name or a balance. Every row in a table is an instance of that entity - like a single person named Bob or a bank account. In an object-oriented framework like Liquidart, we have representations for tables, columns and rows. A class represents a table, its instances are rows, and instance properties are column values. An ORM translates rows in a database to and from objects in an application. Liquidart Database Example #1 Example #2 Class Table Person Bank Account Instance Row A person named Bob Sally's Bank Account Property Column Person's Name Bank Account Balance In Liquidart, each database table-class pairing is called an entity . Collectively, an application's entities are called its data model . Building a Data Model In our heroes application, we will have one type of entity - a \"hero\". To create a new entity, we subclass ManagedObject<T> . Create a new directory lib/model/ and then add a new file to this directory named hero.dart . Add the following code: import 'package:heroes/heroes.dart'; class Hero extends ManagedObject<_Hero> implements _Hero {} class _Hero { @primaryKey int id; @Column(unique: true) String name; } This declares a Hero entity. Entities are always made up of two classes. The _Hero class is a direct mapping of a database table. This table's name will have the same name as the class: _Hero . Every property declared in this class will have a corresponding column in this table. Therefore, the _Hero table will have two columns - id and name . The id column is this table's primary key (a unique identifier for each hero). The name of each hero must be unique. The other class, Hero , is what we work with in our code - when we fetch heroes from a database, they will be instances of Hero . The Hero class is called the instance type of the entity, because that's what we have instances of. _Hero is the table definition of the entity. You won't use the table definition for anything other than describing the database table. An instance type must implement its table definition; this gives our Hero all of the properties of _Hero . An instance type must extend ManagedObject<T> , where T is also the table definition. ManagedObject<T> has behavior for automatically transferring objects to the database and back (among other things). Transient Properties Properties declared in the instance type aren't stored in the database. This is different than properties in the table definition. For example, a database table might have a firstName and lastName , but it's useful in some places to have a fullName property. Declaring the fullName property in the instance type means we have easy access to the full name, but we still store the first and last name individually. Defining a Context Our application needs to know two things to execute database queries: What is the data model (our collection of entities)? What database are we connecting to? Both of these things are set up when an application is first started. In channel.dart , add a new property context and update prepare() : class HeroesChannel extends ApplicationChannel { ManagedContext context; @override Future prepare() async { logger.onRecord.listen((rec) => print(\"$rec ${rec.error ?? \"\"} ${rec.stackTrace ?? \"\"}\")); final dataModel = ManagedDataModel.fromCurrentMirrorSystem(); final persistentStore = PostgreSQLPersistentStore.fromConnectionInfo( \"heroes_user\", \"password\", \"localhost\", 5432, \"heroes\"); context = ManagedContext(dataModel, persistentStore); } @override Controller get entryPoint { ... ManagedDataModel.fromCurrentMirrorSystem() will find all of our ManagedObject<T> subclasses and 'compile' them into a data model. A PostgreSQLPersistentStore takes database connection information that it will use to connect and send queries to a database. Together, these objects are packaged in a ManagedContext . Configuring a Database Connection This tutorial hardcodes the information needed to connect to a database. In a future chapter, we will move these values to a configuration file so that we can change them during tests and various deployment environments. The context will coordinate with these two objects to execute queries and translate objects to and from the database. Controllers that make database queries need a reference to the context. So, we'll want HeroesController to have access to the context. In heroes_controller.dart , add a property and create a new constructor: class HeroesController extends ResourceController { HeroesController(this.context); final ManagedContext context; ... Now that HeroesController requires a context in its constructor, we need to pass it the context we created in prepare() . Update entryPoint in channel.dart . @override Controller get entryPoint { final router = Router(); router .route(\"/heroes/[:id]\") .link(() => HeroesController(context)); router .route(\"/example\") .linkFunction((request) async { return new Response.ok({\"key\": \"value\"}); }); return router; } Now that we've 'injected' this context into our HeroesController constructor, each HeroesController can execute database queries. Service Objects and Dependency Injection Our context is an example of a service object . A service encapsulates logic and state into a single object that can be reused in multiple controllers. A typical service object accesses another server, like a database or another REST API. Some service objects may simply provide a simplified interface to a complex process, like applying transforms to an image. Services are passed in a controller's constructor; this is called dependency injection . Unlike many frameworks, Liquidart does not require a complex dependency injection framework; this is because you write the code to create instances of your controllers and can pass whatever you like in their constructor. Executing Queries Our operation methods in HeroesController currently return heroes from an in-memory list. To fetch data from a database instead of this list, we create and execute instances of Query<T> in our ManagedContext . Let's start by replacing getAllHeroes in heroes_controller.dart . Make sure to import your model/hero.dart file at the top: import 'package:heroes/heroes.dart'; import 'package:heroes/model/hero.dart'; class HeroesController extends ResourceController { HeroesController(this.context); final ManagedContext context; @Operation.get() Future<Response> getAllHeroes() async { final heroQuery = Query<Hero>(context); final heroes = await heroQuery.fetch(); return Response.ok(heroes); } ... Here, we create an instance of Query<Hero> and then execute its fetch() method. The type argument to Query<T> is an instance type; it lets the query know which table to fetch rows from and the type of objects that are returned by the query. The context argument tells it which database to fetch it from. The fetch() execution method returns a List<Hero> . We write that list to the body of the response. Now, let's update getHeroByID to fetch a single hero from the database. @Operation.get('id') Future<Response> getHeroByID(@Bind.path('id') int id) async { final heroQuery = Query<Hero>(context) ..where((h) => h.id).equalTo(id); final hero = await heroQuery.fetchOne(); if (hero == null) { return Response.notFound(); } return Response.ok(hero); } This query does two interesting things. First, it uses the where method to filter heroes that have the same id as the path variable. For example, /heroes/1 will fetch a hero with an id of 1 . This works because Query.where adds a SQL WHERE clause to the query. We'd get the following SQL: SELECT id, name FROM _question WHERE id = 1; The where method uses the property selector syntax. This syntax is a closure that takes an argument of the type being queried, and must return a property of that object. This creates an expression object that targets the selected property. By invoking methods like equalTo on this expression object, a boolean expression is added to the query. Property Selectors Many query configuration methods use the property selector syntax. Setting up a keyboard shortcut (called a Live Template in IntelliJ) to enter the syntax is beneficial. A downloadable settings configuration for IntelliJ exists here that includes this shortcut. The fetchOne() execution method will fetch a single object that fulfills all of the expressions applied to the query. If no database row meets the criteria, null is returned. Our controller returns a 404 Not Found response in that scenario. We have now written code that fetches heroes from a database instead of from in memory, but we don't have a database - yet. fetchObjectWithID, fetchOne() and Unique Properties You can also fetch an object by its primary key with the method ManagedContext.fetchObjectWithID . When fetching with fetchOne , make sure the search criteria is guaranteed to be unique. Setting Up a Database For development, you'll need to install a PostgreSQL server on your local machine. If you are on macOS, use Postgres.app . This native macOS application manages starting and stopping PostgreSQL servers on your machine. For other platforms, see this page . 9.6 or Greater The minimum version of PostgreSQL needed to work with Liquidart is 9.6. If you installed Postgres.app, open the application and select the + button on the bottom left corner of the screen to create a new database server. Choose a version (at least 9.6, but the most recent version is best), name the server whatever you like, and leave the rest of the options unchanged before clicking Create Server . Once the server has been created, click Start . A list of databases available on this server will be shown as named, database icons. Double-click on any of them to open the psql command-line tool. psql For other platforms, psql should be available in your $PATH . You can also add Postgres.app 's psql to your path with the directions here . In psql , create a new database and a user to manage it. CREATE DATABASE heroes; CREATE USER heroes_user WITH createdb; ALTER USER heroes_user WITH password 'password'; GRANT all ON database heroes TO heroes_user; Next, we need to create the table where heroes are stored in this database. From your project directory, run the following command: liquidart db generate This command will create a new migration file . A migration file is a Dart script that runs a series of SQL commands to alter a database's schema. It is created in a new directory in your project named migrations/ . Open migrations/00000001_initial.migration.dart , it should look like this: import 'package:liquidart/liquidart.dart'; import 'dart:async'; class Migration1 extends Migration { @override Future upgrade() async { database.createTable(SchemaTable( \"_Hero\", [ SchemaColumn(\"id\", ManagedPropertyType.bigInteger, isPrimaryKey: true, autoincrement: true, isIndexed: false, isNullable: false, isUnique: false), SchemaColumn(\"name\", ManagedPropertyType.string, isPrimaryKey: false, autoincrement: false, isIndexed: false, isNullable: false, isUnique: true), ], )); } @override Future downgrade() async {} @override Future seed() async {} } In a moment, we'll execute this migration file. That will create a new table named _Hero with columns for id and name . Before we run it, we should seed the database with some initial heroes. In the seed() method, add the following: @override Future seed() async { final heroNames = [\"Mr. Nice\", \"Narco\", \"Bombasto\", \"Celeritas\", \"Magneta\"]; for (final heroName in heroNames) { await database.store.execute(\"INSERT INTO _Hero (name) VALUES (@name)\", substitutionValues: { \"name\": heroName }); } } Apply this migration file to our locally running heroes database with the following command in the project directory: liquidart db upgrade --connect postgres://heroes_user:password@localhost:5432/heroes Re-run your application with liquidart serve . Then, reload http://aqueduct-tutorial.stablekernel.io . Your dashboard of heroes and detail page for each will still show up - but this time, they are sourced from a database. ManagedObjects and Migration Scripts In our migration's seed() method, we executed SQL queries instead of using the Liquidart ORM. It is very important that you do not use Query<T> , ManagedObject<T> or other elements of the Liquidart ORM in migration files. Migration files represent an ordered series of historical steps that describe your database schema. If you replay those steps (which is what executing a migration file does), you will end up with the same database schema every time. However, a ManagedObject<T> subclass changes over time - the definition of a managed object is not historical, it only represents the current point in time. Since a ManagedObject<T> subclass can change, using one in our migration file would mean that our migration file could change. Query Parameters and HTTP Headers In the browser application, the dashboard has a text field for searching heroes. When you enter text into it, it will send the search term to the server by appending a query parameter to GET /heroes . For example, if you entered the text abc , it'd make this request: GET /heroes?name=abc Our Liquidart application can use this value to return a list of heroes that contains the search string. In heroes_controller.dart , modify getAllHeroes() to bind the 'name' query parameter: @Operation.get() Future<Response> getAllHeroes({@Bind.query('name') String name}) async { final heroQuery = Query<Hero>(context); if (name != null) { heroQuery.where((h) => h.name).contains(name, caseSensitive: false); } final heroes = await heroQuery.fetch(); return Response.ok(heroes); } You can re-run your Liquidart application and use the search bar in the client application. The @Bind.query('name') annotation will bind the value of the 'name' query parameter if it is included in the request URL. Otherwise, name will be null. Notice that name is an optional parameter (it is surrounded by curly brackets). An optional parameter in an operation method is also optional in the HTTP request. If we removed the curly brackets from this binding, the 'name' query parameter would become required and the request GET /heroes without ?name=x would fail with a 400 Bad Request. ResourceController Binding There is even more to bindings than we've shown (like automatically parsing bound values into types like int and DateTime). For more information, see ResourceControllers . Binding query and header parameters in a operation method is a good way to make your code more intentional and avoid boilerplate parsing code. Liquidart is able to generate better documentation when using bindings. Next Section: Storing Data","title":"2. Reading from a Database"},{"location":"tutorial/executing_queries/#2-reading-from-a-database","text":"We will continue to build on the last chapter's project, heroes , by storing our heroes in a database. This will let us to edit our heroes and keep the changes when we restart the application.","title":"2. Reading from a Database"},{"location":"tutorial/executing_queries/#object-relational-mapping","text":"A relational database management system (like PostgreSQL or MySQL) stores its data in the form of tables. A table represents some sort of entity - like a person or a bank account. Each table has columns that describe the attributes of that entity - like a name or a balance. Every row in a table is an instance of that entity - like a single person named Bob or a bank account. In an object-oriented framework like Liquidart, we have representations for tables, columns and rows. A class represents a table, its instances are rows, and instance properties are column values. An ORM translates rows in a database to and from objects in an application. Liquidart Database Example #1 Example #2 Class Table Person Bank Account Instance Row A person named Bob Sally's Bank Account Property Column Person's Name Bank Account Balance In Liquidart, each database table-class pairing is called an entity . Collectively, an application's entities are called its data model .","title":"Object-Relational Mapping"},{"location":"tutorial/executing_queries/#building-a-data-model","text":"In our heroes application, we will have one type of entity - a \"hero\". To create a new entity, we subclass ManagedObject<T> . Create a new directory lib/model/ and then add a new file to this directory named hero.dart . Add the following code: import 'package:heroes/heroes.dart'; class Hero extends ManagedObject<_Hero> implements _Hero {} class _Hero { @primaryKey int id; @Column(unique: true) String name; } This declares a Hero entity. Entities are always made up of two classes. The _Hero class is a direct mapping of a database table. This table's name will have the same name as the class: _Hero . Every property declared in this class will have a corresponding column in this table. Therefore, the _Hero table will have two columns - id and name . The id column is this table's primary key (a unique identifier for each hero). The name of each hero must be unique. The other class, Hero , is what we work with in our code - when we fetch heroes from a database, they will be instances of Hero . The Hero class is called the instance type of the entity, because that's what we have instances of. _Hero is the table definition of the entity. You won't use the table definition for anything other than describing the database table. An instance type must implement its table definition; this gives our Hero all of the properties of _Hero . An instance type must extend ManagedObject<T> , where T is also the table definition. ManagedObject<T> has behavior for automatically transferring objects to the database and back (among other things). Transient Properties Properties declared in the instance type aren't stored in the database. This is different than properties in the table definition. For example, a database table might have a firstName and lastName , but it's useful in some places to have a fullName property. Declaring the fullName property in the instance type means we have easy access to the full name, but we still store the first and last name individually.","title":"Building a Data Model"},{"location":"tutorial/executing_queries/#defining-a-context","text":"Our application needs to know two things to execute database queries: What is the data model (our collection of entities)? What database are we connecting to? Both of these things are set up when an application is first started. In channel.dart , add a new property context and update prepare() : class HeroesChannel extends ApplicationChannel { ManagedContext context; @override Future prepare() async { logger.onRecord.listen((rec) => print(\"$rec ${rec.error ?? \"\"} ${rec.stackTrace ?? \"\"}\")); final dataModel = ManagedDataModel.fromCurrentMirrorSystem(); final persistentStore = PostgreSQLPersistentStore.fromConnectionInfo( \"heroes_user\", \"password\", \"localhost\", 5432, \"heroes\"); context = ManagedContext(dataModel, persistentStore); } @override Controller get entryPoint { ... ManagedDataModel.fromCurrentMirrorSystem() will find all of our ManagedObject<T> subclasses and 'compile' them into a data model. A PostgreSQLPersistentStore takes database connection information that it will use to connect and send queries to a database. Together, these objects are packaged in a ManagedContext . Configuring a Database Connection This tutorial hardcodes the information needed to connect to a database. In a future chapter, we will move these values to a configuration file so that we can change them during tests and various deployment environments. The context will coordinate with these two objects to execute queries and translate objects to and from the database. Controllers that make database queries need a reference to the context. So, we'll want HeroesController to have access to the context. In heroes_controller.dart , add a property and create a new constructor: class HeroesController extends ResourceController { HeroesController(this.context); final ManagedContext context; ... Now that HeroesController requires a context in its constructor, we need to pass it the context we created in prepare() . Update entryPoint in channel.dart . @override Controller get entryPoint { final router = Router(); router .route(\"/heroes/[:id]\") .link(() => HeroesController(context)); router .route(\"/example\") .linkFunction((request) async { return new Response.ok({\"key\": \"value\"}); }); return router; } Now that we've 'injected' this context into our HeroesController constructor, each HeroesController can execute database queries. Service Objects and Dependency Injection Our context is an example of a service object . A service encapsulates logic and state into a single object that can be reused in multiple controllers. A typical service object accesses another server, like a database or another REST API. Some service objects may simply provide a simplified interface to a complex process, like applying transforms to an image. Services are passed in a controller's constructor; this is called dependency injection . Unlike many frameworks, Liquidart does not require a complex dependency injection framework; this is because you write the code to create instances of your controllers and can pass whatever you like in their constructor.","title":"Defining a Context"},{"location":"tutorial/executing_queries/#executing-queries","text":"Our operation methods in HeroesController currently return heroes from an in-memory list. To fetch data from a database instead of this list, we create and execute instances of Query<T> in our ManagedContext . Let's start by replacing getAllHeroes in heroes_controller.dart . Make sure to import your model/hero.dart file at the top: import 'package:heroes/heroes.dart'; import 'package:heroes/model/hero.dart'; class HeroesController extends ResourceController { HeroesController(this.context); final ManagedContext context; @Operation.get() Future<Response> getAllHeroes() async { final heroQuery = Query<Hero>(context); final heroes = await heroQuery.fetch(); return Response.ok(heroes); } ... Here, we create an instance of Query<Hero> and then execute its fetch() method. The type argument to Query<T> is an instance type; it lets the query know which table to fetch rows from and the type of objects that are returned by the query. The context argument tells it which database to fetch it from. The fetch() execution method returns a List<Hero> . We write that list to the body of the response. Now, let's update getHeroByID to fetch a single hero from the database. @Operation.get('id') Future<Response> getHeroByID(@Bind.path('id') int id) async { final heroQuery = Query<Hero>(context) ..where((h) => h.id).equalTo(id); final hero = await heroQuery.fetchOne(); if (hero == null) { return Response.notFound(); } return Response.ok(hero); } This query does two interesting things. First, it uses the where method to filter heroes that have the same id as the path variable. For example, /heroes/1 will fetch a hero with an id of 1 . This works because Query.where adds a SQL WHERE clause to the query. We'd get the following SQL: SELECT id, name FROM _question WHERE id = 1; The where method uses the property selector syntax. This syntax is a closure that takes an argument of the type being queried, and must return a property of that object. This creates an expression object that targets the selected property. By invoking methods like equalTo on this expression object, a boolean expression is added to the query. Property Selectors Many query configuration methods use the property selector syntax. Setting up a keyboard shortcut (called a Live Template in IntelliJ) to enter the syntax is beneficial. A downloadable settings configuration for IntelliJ exists here that includes this shortcut. The fetchOne() execution method will fetch a single object that fulfills all of the expressions applied to the query. If no database row meets the criteria, null is returned. Our controller returns a 404 Not Found response in that scenario. We have now written code that fetches heroes from a database instead of from in memory, but we don't have a database - yet. fetchObjectWithID, fetchOne() and Unique Properties You can also fetch an object by its primary key with the method ManagedContext.fetchObjectWithID . When fetching with fetchOne , make sure the search criteria is guaranteed to be unique.","title":"Executing Queries"},{"location":"tutorial/executing_queries/#setting-up-a-database","text":"For development, you'll need to install a PostgreSQL server on your local machine. If you are on macOS, use Postgres.app . This native macOS application manages starting and stopping PostgreSQL servers on your machine. For other platforms, see this page . 9.6 or Greater The minimum version of PostgreSQL needed to work with Liquidart is 9.6. If you installed Postgres.app, open the application and select the + button on the bottom left corner of the screen to create a new database server. Choose a version (at least 9.6, but the most recent version is best), name the server whatever you like, and leave the rest of the options unchanged before clicking Create Server . Once the server has been created, click Start . A list of databases available on this server will be shown as named, database icons. Double-click on any of them to open the psql command-line tool. psql For other platforms, psql should be available in your $PATH . You can also add Postgres.app 's psql to your path with the directions here . In psql , create a new database and a user to manage it. CREATE DATABASE heroes; CREATE USER heroes_user WITH createdb; ALTER USER heroes_user WITH password 'password'; GRANT all ON database heroes TO heroes_user; Next, we need to create the table where heroes are stored in this database. From your project directory, run the following command: liquidart db generate This command will create a new migration file . A migration file is a Dart script that runs a series of SQL commands to alter a database's schema. It is created in a new directory in your project named migrations/ . Open migrations/00000001_initial.migration.dart , it should look like this: import 'package:liquidart/liquidart.dart'; import 'dart:async'; class Migration1 extends Migration { @override Future upgrade() async { database.createTable(SchemaTable( \"_Hero\", [ SchemaColumn(\"id\", ManagedPropertyType.bigInteger, isPrimaryKey: true, autoincrement: true, isIndexed: false, isNullable: false, isUnique: false), SchemaColumn(\"name\", ManagedPropertyType.string, isPrimaryKey: false, autoincrement: false, isIndexed: false, isNullable: false, isUnique: true), ], )); } @override Future downgrade() async {} @override Future seed() async {} } In a moment, we'll execute this migration file. That will create a new table named _Hero with columns for id and name . Before we run it, we should seed the database with some initial heroes. In the seed() method, add the following: @override Future seed() async { final heroNames = [\"Mr. Nice\", \"Narco\", \"Bombasto\", \"Celeritas\", \"Magneta\"]; for (final heroName in heroNames) { await database.store.execute(\"INSERT INTO _Hero (name) VALUES (@name)\", substitutionValues: { \"name\": heroName }); } } Apply this migration file to our locally running heroes database with the following command in the project directory: liquidart db upgrade --connect postgres://heroes_user:password@localhost:5432/heroes Re-run your application with liquidart serve . Then, reload http://aqueduct-tutorial.stablekernel.io . Your dashboard of heroes and detail page for each will still show up - but this time, they are sourced from a database. ManagedObjects and Migration Scripts In our migration's seed() method, we executed SQL queries instead of using the Liquidart ORM. It is very important that you do not use Query<T> , ManagedObject<T> or other elements of the Liquidart ORM in migration files. Migration files represent an ordered series of historical steps that describe your database schema. If you replay those steps (which is what executing a migration file does), you will end up with the same database schema every time. However, a ManagedObject<T> subclass changes over time - the definition of a managed object is not historical, it only represents the current point in time. Since a ManagedObject<T> subclass can change, using one in our migration file would mean that our migration file could change.","title":"Setting Up a Database"},{"location":"tutorial/executing_queries/#query-parameters-and-http-headers","text":"In the browser application, the dashboard has a text field for searching heroes. When you enter text into it, it will send the search term to the server by appending a query parameter to GET /heroes . For example, if you entered the text abc , it'd make this request: GET /heroes?name=abc Our Liquidart application can use this value to return a list of heroes that contains the search string. In heroes_controller.dart , modify getAllHeroes() to bind the 'name' query parameter: @Operation.get() Future<Response> getAllHeroes({@Bind.query('name') String name}) async { final heroQuery = Query<Hero>(context); if (name != null) { heroQuery.where((h) => h.name).contains(name, caseSensitive: false); } final heroes = await heroQuery.fetch(); return Response.ok(heroes); } You can re-run your Liquidart application and use the search bar in the client application. The @Bind.query('name') annotation will bind the value of the 'name' query parameter if it is included in the request URL. Otherwise, name will be null. Notice that name is an optional parameter (it is surrounded by curly brackets). An optional parameter in an operation method is also optional in the HTTP request. If we removed the curly brackets from this binding, the 'name' query parameter would become required and the request GET /heroes without ?name=x would fail with a 400 Bad Request. ResourceController Binding There is even more to bindings than we've shown (like automatically parsing bound values into types like int and DateTime). For more information, see ResourceControllers . Binding query and header parameters in a operation method is a good way to make your code more intentional and avoid boilerplate parsing code. Liquidart is able to generate better documentation when using bindings.","title":"Query Parameters and HTTP Headers"},{"location":"tutorial/executing_queries/#next-section-storing-data","text":"","title":"Next Section: Storing Data"},{"location":"tutorial/getting_started/","text":"1. Getting Started By the end of this tutorial, you will have created an Liquidart application that serves fictional heroes from a PostgreSQL database. You will learn the following: Run an Liquidart application Route HTTP requests to the appropriate handler in your code Store and retrieve database data Write automated tests for each endpoint Require authorization for HTTP requests Getting Help If at anytime you get stuck, hop on over to the Liquidart Github Discussions. You can also see a finished version of this application here . Installation To get started, make sure you have the following software installed: Dart ( Install Instructions ) IntelliJ IDEA or any other Jetbrains IDE, including the free Community Edition ( Install Instructions ) The IntelliJ IDEA Dart Plugin ( Install Instructions ) Install the liquidart command line tool by running the following command in your shell: pub global activate liquidart PATH Warning If you get warning text about your PATH, make sure to read it before moving on. Creating a Project Create a new project named heroes by entering the following in your shell: liquidart create heroes This creates a heroes project directory. Open this directory with IntelliJ IDEA by dragging the project folder onto IntellIJ IDEA's icon. In IntelliJ's project view, locate the lib directory; this is where your project's code will go. This project has two source files - heroes.dart and channel.dart . Open the file heroes.dart . Click Enable Dart Support in the top right corner of the editor. Handling HTTP Requests In your browser, navigate to http://liquidart-tutorial.stablekernel.io . This browser application is a 'Hero Manager' - it allows a user to view, create, delete and update heroes. (It is a slightly modified version of the AngularDart Tour of Heroes Tutorial .) It will make HTTP requests to http://localhost:8888 to fetch and manipulate hero data. The application you will build in this tutorial respond to those requests. Running the Browser Application Locally The browser application is served over HTTP so that it can access your Liquidart application when it runs locally on your machine. Your browser may warn you about navigating to an insecure webpage, because it is in fact insecure. You can run this application locally by grabbing the source code from here . In this first chapter, you will write code to handle two requests: one to get a list of heroes, and the other to get a single hero by its identifier. Those requests are: GET /heroes to the list of heroes GET /heroes/:id to get an individual hero HTTP Operation Shorthand The term GET /heroes is called an operation. It is the combination of the HTTP method and the path of the request. Each operation is unique to an application, so your code is segmented into units for each operation. Sections with a colon, like the ':id' segment, are variable: they can be 1, 2, 3, and so on. Controller Objects Handle Requests Requests are handled by controller objects . A controller object can respond to a request. It can also take other action and let another controller respond. For example, it might check if the request is authorized, or send analytical data to some other service. Controllers are composed together, and each controller in the composition performs its logic in order. This allows for some controllers to be reused, and for better code organization. A composition of controllers is called a channel because requests flow in one direction through the controllers. Our application will link two controllers: a Router that makes sure the request path is /heroes or /heroes/:id a HeroesControllers that responds with hero objects Your application starts with a channel object called the application channel . You link the controllers in your application to this channel. Each application has a subclass of ApplicationChannel that you override methods in to set up your controllers. This type is already declared in lib/channel.dart - open this file and find ApplicationChannel.entryPoint : @override Controller get entryPoint { final router = Router(); router .route('/example') .linkFunction((request) async { return Response.ok({'key': 'value'}); }); return router; } When your application gets a request, the entryPoint controller is the first to handle it. In our case, this is a Router - a subclass of Controller . Controller Subclassing Every controller you use will be a subclass of Controller. There are some controller subclasses already in Liquidart for common behaviors. You use the route method on a router to attach a controller to a route . A route is a string syntax that matches the path of a request. In our current implementation, the route will match every request with the path /example . When that request is received, a linked function runs and returns a 200 OK response with an example JSON object body. We need to route the path /heroes to a controller of our own, so we can control what happens. Let's create a HeroesController . Create a new file in lib/controller/heroes_controller.dart and add the following code (you will need to create the subdirectory lib/controller/ ): import 'package:liquidart/liquidart.dart'; import 'package:heroes/heroes.dart'; class HeroesController extends Controller { final _heroes = [ {'id': 11, 'name': 'Mr. Nice'}, {'id': 12, 'name': 'Narco'}, {'id': 13, 'name': 'Bombasto'}, {'id': 14, 'name': 'Celeritas'}, {'id': 15, 'name': 'Magneta'}, ]; @override Future<RequestOrResponse> handle(Request request) async { return Response.ok(_heroes); } } Notice that HeroesController is a subclass of Controller ; this is what makes it a controller object. It overrides its handle method by returning a Response object. This response object has a 200 OK status code, and it body contains a JSON-encoded list of hero objects. When a controller returns a Response object from its handle method, it is sent to the client. Right now, our HeroesController isn't hooked up to the application channel. We need to link it to the router. First, import our new file at the top of channel.dart . import 'controller/heroes_controller.dart'; Then link this HeroesController to the Router for the path /heroes: @override Controller get entryPoint { final router = Router(); router .route('/heroes') .link(() => HeroesController()); router .route('/example') .linkFunction((request) async { return Response.ok({'key': 'value'}); }); return router; } We now have a application that will return a list of heroes. In the project directory, run the following command from the command-line: liquidart serve This will start your application running locally. Reload the browser page http://liquidart-tutorial.stablekernel.io . It will make a request to http://localhost:8888/heroes and your application will serve it. You'll see your heroes in your web browser: You can also see the actual response of your request by entering the following into your shell: curl -X GET http://localhost:8888/heroes You'll get JSON output like this: [ {\"id\":11,\"name\":\"Mr. Nice\"}, {\"id\":12,\"name\":\"Narco\"}, {\"id\":13,\"name\":\"Bombasto\"}, {\"id\":14,\"name\":\"Celeritas\"}, {\"id\":15,\"name\":\"Magneta\"} ] You'll also see this request logged in the shell that you started liquidart serve in. Linking Controllers When a controller handles a request, it can either send a response or let one of its linked controllers handle the request. By default, a Router will send a 404 Not Found response for any request. Adding a route to a Router creates an entry point to a new channel that controllers can be linked to. In our application, HeroesController is linked to the route /heroes . Controllers come in two different flavors: endpoint and middleware. Endpoint controllers, like HeroesController , always send a response. They implement the behavior that a request is seeking. Middleware controllers, like Router , handles requests before they reach an endpoint controller. A router, for example, handles a request by directing it to the right controller. Controllers like Authorizer verify the authorization of the request. You can create all kinds of controllers to provide any behavior you like. A channel can have zero or many middleware controllers, but must end in an endpoint controller. Most controllers can only have one linked controller, but a Router allows for many. For example, a larger application might look like this: @override Controller get entryPoint { final router = Router(); router .route('/users') .link(() => APIKeyValidator()) .link(() => Authorizer.bearer()) .link(() => UsersController()); router .route('/posts') .link(() => APIKeyValidator()) .link(() => PostsController()); return router; } Each of these objects is a subclass of Controller , giving them the ability to be linked together to handle requests. A request goes through controllers in the order they are linked. A request for the path /users will go through an APIKeyValidator , an Authorizer and finally a UsersController . Each of these controllers has an opportunity to respond, preventing the next controller from receiving the request. Advanced Routing Right now, our application handles GET /heroes requests. The browser application uses the this list to populate its hero dashboard. If we click on an individual hero, the browser application will display an individual hero. When navigating to this page, the browser application makes a request to our server for an individual hero. This request contains the unique id of the selected hero in the path, e.g. /heroes/11 or /heroes/13 . Our server doesn't handle this request yet - it only handles requests that have exactly the path /heroes . Since a request for individual heroes will have a path that changes depending on the hero, we need our route to include a path variable . A path variable is a segment of route that matches a value for the same segment in the incoming request path. A path variable is a segment prefixed with a colon (:). For example, the route /heroes/:id contains a path variable named id. If the request path is /heroes/1 , /heroes/2 , and so on, the request will be sent to our HeroesController . The HeroesController will have access to the value of the path variable to determine which hero to return. There's one hiccup. The route /heroes/:id no longer matches the path /heroes . It'd be a lot easier to organize our code if both /heroes and /heroes/:id went to our HeroesController ; it does heroic stuff. For this reason, we can declare the :id portion of our route to be optional by wrapping it in square brackets. In channel.dart , modify the /heroes route: router .route('/heroes/[:id]') .link(() => HeroesController()); Since the second segment of the path is optional, the path /heroes still matches the route. If the path contains a second segment, the value of that segment is bound to the path variable named id . We can access path variables through the Request object. In heroes_controller.dart , modify handle : // In just a moment, we'll replace this code with something even better, // but it's important to understand where this information comes from first! @override Future<RequestOrResponse> handle(Request request) async { if (request.path.variables.containsKey('id')) { final id = int.parse(request.path.variables['id']); final hero = _heroes.firstWhere((hero) => hero['id'] == id, orElse: () => null); if (hero == null) { return Response.notFound(); } return Response.ok(hero); } return Response.ok(_heroes); } In your shell currently running the application, hit Ctrl-C to stop the application. Then, run liquidart serve again. In the browser application, click on a hero and you will be taken to a detail page for that hero. You can verify that your server is responding correctly by executing curl -X GET http://localhost:8888/heroes/11 to view the single hero object. You can also trigger a 404 Not Found response by getting a hero that doesn't exist. ResourceControllers and Operation Methods Our HeroesController is OK right now, but it'll soon run into a problem: what happens when we want to create a new hero? Or update an existing hero's name? Our handle method will start to get unmanageable, quickly. That's where ResourceController comes in. A ResourceController allows you to create a distinct method for each operation that we can perform on our heroes. One method will handle getting a list of heroes, another will handle getting a single hero, and so on. Each method has an annotation that identifies the HTTP method and path variables the request must have to trigger it. In heroes_controller.dart , replace HeroesController with the following: class HeroesController extends ResourceController { final _heroes = [ {'id': 11, 'name': 'Mr. Nice'}, {'id': 12, 'name': 'Narco'}, {'id': 13, 'name': 'Bombasto'}, {'id': 14, 'name': 'Celeritas'}, {'id': 15, 'name': 'Magneta'}, ]; @Operation.get() Future<Response> getAllHeroes() async { return Response.ok(_heroes); } @Operation.get('id') Future<Response> getHeroByID() async { final id = int.parse(request.path.variables['id']); final hero = _heroes.firstWhere((hero) => hero['id'] == id, orElse: () => null); if (hero == null) { return Response.notFound(); } return Response.ok(hero); } } Notice that we didn't have to override handle in ResourceController . A ResourceController implements this method to call one of our operation methods. An operation method - like getAllHeroes and getHeroByID - must have an Operation annotation. The named constructor Operation.get means these methods get called when the request's method is GET. An operation method must also return a Future<Response> . getHeroByID 's annotation also has an argument - the name of our path variable id . If that path variable exists in the request's path, getHeroByID will be called. If it doesn't exist, getAllHeroes will be called. Naming Operation Methods The plain English phrase for an operation - like 'get hero by id' - is a really good name for an operation method and a good name will be useful when you generate OpenAPI documentation from your code. Reload the application by hitting Ctrl-C in the terminal that ran liquidart serve and then run liquidart serve again. The browser application should still behave the same. Browser Clients In addition to curl , you can create a SwaggerUI browser application that executes requests against your locally running application. In your project directory, run liquidart document client and it will generate a file named client.html . Open this file in your browser for a UI that constructs and executes requests that your application supports. Request Binding In our getHeroByID method, we make a dangerous assumption that the path variable 'id' can be parsed into an integer. If 'id' were something else, like a string, int.parse would throw an exception. When exceptions are thrown in operation methods, the controller catches it and sends a 500 Server Error response. 500s are bad, they don't tell the client what's wrong. A 404 Not Found is a better response here, but writing the code to catch that exception and create this response is cumbersome. Instead, we can rely on a feature of operation methods called request binding. An operation method can declare parameters and bind them to properties of the request. When our operation method gets called, it will be passed values from the request as arguments. Request bindings automatically parse values into the type of the parameter (and return a better error response if parsing fails). Change the method getHeroByID() : @Operation.get('id') Future<Response> getHeroByID(@Bind.path('id') int id) async { final hero = _heroes.firstWhere((hero) => hero['id'] == id, orElse: () => null); if (hero == null) { return Response.notFound(); } return Response.ok(hero); } The value of the path variable id will be parsed as an integer and be available to this method in the id parameter. The @Bind annotation on an operation method parameter tells Liquidart the value from the request we want bound. Using the named constructor Bind.path binds a path variable, and the name of that variable is indicated in the argument to this constructor. You can bind path variables, headers, query parameters and bodies. When binding path variables, we have to specify which path variable with the argument to @Bind.path(pathVariableName) . Bound Parameter Names The name of a bound parameter doesn't have to match the name of the path variable. We could have declared it as @Bind.path('id') int heroID . Only the argument to Bind 's constructor must match the actual name of the path variable. This is valuable for other types of bindings, like headers, that may contain characters that aren't valid Dart variable names, e.g. X-API-Key. The More You Know: Multi-threading and Application State In this simple exercise, we used a constant list of heroes as our source of data. For a simple getting-your-feet-wet demo, this is fine. However, in a real application, you'd store this data in a database. That way you could add data to it and not risk losing it when the application was restarted. More generally, a web server should never hang on to data that can change. While previously just a best practice, stateless web servers are becoming a requirement with the prevalence of containerization and tools like Kubernetes. Liquidart makes it a bit easier to detect violations of this rule with its multi-threading strategy. When you run an Liquidart application, it creates multiple threads. Each of these threads has its own isolated heap in memory; meaning data that exists on one thread can't be accessed from other threads. In Dart, these isolated threads are called isolates. An instance of your application channel is created for each isolate. Each HTTP request is given to just one of the isolates to be handled. In a sense, your one application behaves the same as running your application on multiple servers behind a load balancer. (It also makes your application substantially faster.) If you are storing any data in your application, you'll find out really quickly. Why? A request that changes data will only change that data in one of your application's isolates. When you make a request to get that data again, its unlikely that you'll see the changes - another isolate with different data will probably handle that request. Next Chapter: Reading from a Database","title":"1. Getting Started"},{"location":"tutorial/getting_started/#1-getting-started","text":"By the end of this tutorial, you will have created an Liquidart application that serves fictional heroes from a PostgreSQL database. You will learn the following: Run an Liquidart application Route HTTP requests to the appropriate handler in your code Store and retrieve database data Write automated tests for each endpoint Require authorization for HTTP requests Getting Help If at anytime you get stuck, hop on over to the Liquidart Github Discussions. You can also see a finished version of this application here .","title":"1. Getting Started"},{"location":"tutorial/getting_started/#installation","text":"To get started, make sure you have the following software installed: Dart ( Install Instructions ) IntelliJ IDEA or any other Jetbrains IDE, including the free Community Edition ( Install Instructions ) The IntelliJ IDEA Dart Plugin ( Install Instructions ) Install the liquidart command line tool by running the following command in your shell: pub global activate liquidart PATH Warning If you get warning text about your PATH, make sure to read it before moving on.","title":"Installation"},{"location":"tutorial/getting_started/#creating-a-project","text":"Create a new project named heroes by entering the following in your shell: liquidart create heroes This creates a heroes project directory. Open this directory with IntelliJ IDEA by dragging the project folder onto IntellIJ IDEA's icon. In IntelliJ's project view, locate the lib directory; this is where your project's code will go. This project has two source files - heroes.dart and channel.dart . Open the file heroes.dart . Click Enable Dart Support in the top right corner of the editor.","title":"Creating a Project"},{"location":"tutorial/getting_started/#handling-http-requests","text":"In your browser, navigate to http://liquidart-tutorial.stablekernel.io . This browser application is a 'Hero Manager' - it allows a user to view, create, delete and update heroes. (It is a slightly modified version of the AngularDart Tour of Heroes Tutorial .) It will make HTTP requests to http://localhost:8888 to fetch and manipulate hero data. The application you will build in this tutorial respond to those requests. Running the Browser Application Locally The browser application is served over HTTP so that it can access your Liquidart application when it runs locally on your machine. Your browser may warn you about navigating to an insecure webpage, because it is in fact insecure. You can run this application locally by grabbing the source code from here . In this first chapter, you will write code to handle two requests: one to get a list of heroes, and the other to get a single hero by its identifier. Those requests are: GET /heroes to the list of heroes GET /heroes/:id to get an individual hero HTTP Operation Shorthand The term GET /heroes is called an operation. It is the combination of the HTTP method and the path of the request. Each operation is unique to an application, so your code is segmented into units for each operation. Sections with a colon, like the ':id' segment, are variable: they can be 1, 2, 3, and so on.","title":"Handling HTTP Requests"},{"location":"tutorial/getting_started/#controller-objects-handle-requests","text":"Requests are handled by controller objects . A controller object can respond to a request. It can also take other action and let another controller respond. For example, it might check if the request is authorized, or send analytical data to some other service. Controllers are composed together, and each controller in the composition performs its logic in order. This allows for some controllers to be reused, and for better code organization. A composition of controllers is called a channel because requests flow in one direction through the controllers. Our application will link two controllers: a Router that makes sure the request path is /heroes or /heroes/:id a HeroesControllers that responds with hero objects Your application starts with a channel object called the application channel . You link the controllers in your application to this channel. Each application has a subclass of ApplicationChannel that you override methods in to set up your controllers. This type is already declared in lib/channel.dart - open this file and find ApplicationChannel.entryPoint : @override Controller get entryPoint { final router = Router(); router .route('/example') .linkFunction((request) async { return Response.ok({'key': 'value'}); }); return router; } When your application gets a request, the entryPoint controller is the first to handle it. In our case, this is a Router - a subclass of Controller . Controller Subclassing Every controller you use will be a subclass of Controller. There are some controller subclasses already in Liquidart for common behaviors. You use the route method on a router to attach a controller to a route . A route is a string syntax that matches the path of a request. In our current implementation, the route will match every request with the path /example . When that request is received, a linked function runs and returns a 200 OK response with an example JSON object body. We need to route the path /heroes to a controller of our own, so we can control what happens. Let's create a HeroesController . Create a new file in lib/controller/heroes_controller.dart and add the following code (you will need to create the subdirectory lib/controller/ ): import 'package:liquidart/liquidart.dart'; import 'package:heroes/heroes.dart'; class HeroesController extends Controller { final _heroes = [ {'id': 11, 'name': 'Mr. Nice'}, {'id': 12, 'name': 'Narco'}, {'id': 13, 'name': 'Bombasto'}, {'id': 14, 'name': 'Celeritas'}, {'id': 15, 'name': 'Magneta'}, ]; @override Future<RequestOrResponse> handle(Request request) async { return Response.ok(_heroes); } } Notice that HeroesController is a subclass of Controller ; this is what makes it a controller object. It overrides its handle method by returning a Response object. This response object has a 200 OK status code, and it body contains a JSON-encoded list of hero objects. When a controller returns a Response object from its handle method, it is sent to the client. Right now, our HeroesController isn't hooked up to the application channel. We need to link it to the router. First, import our new file at the top of channel.dart . import 'controller/heroes_controller.dart'; Then link this HeroesController to the Router for the path /heroes: @override Controller get entryPoint { final router = Router(); router .route('/heroes') .link(() => HeroesController()); router .route('/example') .linkFunction((request) async { return Response.ok({'key': 'value'}); }); return router; } We now have a application that will return a list of heroes. In the project directory, run the following command from the command-line: liquidart serve This will start your application running locally. Reload the browser page http://liquidart-tutorial.stablekernel.io . It will make a request to http://localhost:8888/heroes and your application will serve it. You'll see your heroes in your web browser: You can also see the actual response of your request by entering the following into your shell: curl -X GET http://localhost:8888/heroes You'll get JSON output like this: [ {\"id\":11,\"name\":\"Mr. Nice\"}, {\"id\":12,\"name\":\"Narco\"}, {\"id\":13,\"name\":\"Bombasto\"}, {\"id\":14,\"name\":\"Celeritas\"}, {\"id\":15,\"name\":\"Magneta\"} ] You'll also see this request logged in the shell that you started liquidart serve in.","title":"Controller Objects Handle Requests"},{"location":"tutorial/getting_started/#linking-controllers","text":"When a controller handles a request, it can either send a response or let one of its linked controllers handle the request. By default, a Router will send a 404 Not Found response for any request. Adding a route to a Router creates an entry point to a new channel that controllers can be linked to. In our application, HeroesController is linked to the route /heroes . Controllers come in two different flavors: endpoint and middleware. Endpoint controllers, like HeroesController , always send a response. They implement the behavior that a request is seeking. Middleware controllers, like Router , handles requests before they reach an endpoint controller. A router, for example, handles a request by directing it to the right controller. Controllers like Authorizer verify the authorization of the request. You can create all kinds of controllers to provide any behavior you like. A channel can have zero or many middleware controllers, but must end in an endpoint controller. Most controllers can only have one linked controller, but a Router allows for many. For example, a larger application might look like this: @override Controller get entryPoint { final router = Router(); router .route('/users') .link(() => APIKeyValidator()) .link(() => Authorizer.bearer()) .link(() => UsersController()); router .route('/posts') .link(() => APIKeyValidator()) .link(() => PostsController()); return router; } Each of these objects is a subclass of Controller , giving them the ability to be linked together to handle requests. A request goes through controllers in the order they are linked. A request for the path /users will go through an APIKeyValidator , an Authorizer and finally a UsersController . Each of these controllers has an opportunity to respond, preventing the next controller from receiving the request.","title":"Linking Controllers"},{"location":"tutorial/getting_started/#advanced-routing","text":"Right now, our application handles GET /heroes requests. The browser application uses the this list to populate its hero dashboard. If we click on an individual hero, the browser application will display an individual hero. When navigating to this page, the browser application makes a request to our server for an individual hero. This request contains the unique id of the selected hero in the path, e.g. /heroes/11 or /heroes/13 . Our server doesn't handle this request yet - it only handles requests that have exactly the path /heroes . Since a request for individual heroes will have a path that changes depending on the hero, we need our route to include a path variable . A path variable is a segment of route that matches a value for the same segment in the incoming request path. A path variable is a segment prefixed with a colon (:). For example, the route /heroes/:id contains a path variable named id. If the request path is /heroes/1 , /heroes/2 , and so on, the request will be sent to our HeroesController . The HeroesController will have access to the value of the path variable to determine which hero to return. There's one hiccup. The route /heroes/:id no longer matches the path /heroes . It'd be a lot easier to organize our code if both /heroes and /heroes/:id went to our HeroesController ; it does heroic stuff. For this reason, we can declare the :id portion of our route to be optional by wrapping it in square brackets. In channel.dart , modify the /heroes route: router .route('/heroes/[:id]') .link(() => HeroesController()); Since the second segment of the path is optional, the path /heroes still matches the route. If the path contains a second segment, the value of that segment is bound to the path variable named id . We can access path variables through the Request object. In heroes_controller.dart , modify handle : // In just a moment, we'll replace this code with something even better, // but it's important to understand where this information comes from first! @override Future<RequestOrResponse> handle(Request request) async { if (request.path.variables.containsKey('id')) { final id = int.parse(request.path.variables['id']); final hero = _heroes.firstWhere((hero) => hero['id'] == id, orElse: () => null); if (hero == null) { return Response.notFound(); } return Response.ok(hero); } return Response.ok(_heroes); } In your shell currently running the application, hit Ctrl-C to stop the application. Then, run liquidart serve again. In the browser application, click on a hero and you will be taken to a detail page for that hero. You can verify that your server is responding correctly by executing curl -X GET http://localhost:8888/heroes/11 to view the single hero object. You can also trigger a 404 Not Found response by getting a hero that doesn't exist.","title":"Advanced Routing"},{"location":"tutorial/getting_started/#resourcecontrollers-and-operation-methods","text":"Our HeroesController is OK right now, but it'll soon run into a problem: what happens when we want to create a new hero? Or update an existing hero's name? Our handle method will start to get unmanageable, quickly. That's where ResourceController comes in. A ResourceController allows you to create a distinct method for each operation that we can perform on our heroes. One method will handle getting a list of heroes, another will handle getting a single hero, and so on. Each method has an annotation that identifies the HTTP method and path variables the request must have to trigger it. In heroes_controller.dart , replace HeroesController with the following: class HeroesController extends ResourceController { final _heroes = [ {'id': 11, 'name': 'Mr. Nice'}, {'id': 12, 'name': 'Narco'}, {'id': 13, 'name': 'Bombasto'}, {'id': 14, 'name': 'Celeritas'}, {'id': 15, 'name': 'Magneta'}, ]; @Operation.get() Future<Response> getAllHeroes() async { return Response.ok(_heroes); } @Operation.get('id') Future<Response> getHeroByID() async { final id = int.parse(request.path.variables['id']); final hero = _heroes.firstWhere((hero) => hero['id'] == id, orElse: () => null); if (hero == null) { return Response.notFound(); } return Response.ok(hero); } } Notice that we didn't have to override handle in ResourceController . A ResourceController implements this method to call one of our operation methods. An operation method - like getAllHeroes and getHeroByID - must have an Operation annotation. The named constructor Operation.get means these methods get called when the request's method is GET. An operation method must also return a Future<Response> . getHeroByID 's annotation also has an argument - the name of our path variable id . If that path variable exists in the request's path, getHeroByID will be called. If it doesn't exist, getAllHeroes will be called. Naming Operation Methods The plain English phrase for an operation - like 'get hero by id' - is a really good name for an operation method and a good name will be useful when you generate OpenAPI documentation from your code. Reload the application by hitting Ctrl-C in the terminal that ran liquidart serve and then run liquidart serve again. The browser application should still behave the same. Browser Clients In addition to curl , you can create a SwaggerUI browser application that executes requests against your locally running application. In your project directory, run liquidart document client and it will generate a file named client.html . Open this file in your browser for a UI that constructs and executes requests that your application supports.","title":"ResourceControllers and Operation Methods"},{"location":"tutorial/getting_started/#request-binding","text":"In our getHeroByID method, we make a dangerous assumption that the path variable 'id' can be parsed into an integer. If 'id' were something else, like a string, int.parse would throw an exception. When exceptions are thrown in operation methods, the controller catches it and sends a 500 Server Error response. 500s are bad, they don't tell the client what's wrong. A 404 Not Found is a better response here, but writing the code to catch that exception and create this response is cumbersome. Instead, we can rely on a feature of operation methods called request binding. An operation method can declare parameters and bind them to properties of the request. When our operation method gets called, it will be passed values from the request as arguments. Request bindings automatically parse values into the type of the parameter (and return a better error response if parsing fails). Change the method getHeroByID() : @Operation.get('id') Future<Response> getHeroByID(@Bind.path('id') int id) async { final hero = _heroes.firstWhere((hero) => hero['id'] == id, orElse: () => null); if (hero == null) { return Response.notFound(); } return Response.ok(hero); } The value of the path variable id will be parsed as an integer and be available to this method in the id parameter. The @Bind annotation on an operation method parameter tells Liquidart the value from the request we want bound. Using the named constructor Bind.path binds a path variable, and the name of that variable is indicated in the argument to this constructor. You can bind path variables, headers, query parameters and bodies. When binding path variables, we have to specify which path variable with the argument to @Bind.path(pathVariableName) . Bound Parameter Names The name of a bound parameter doesn't have to match the name of the path variable. We could have declared it as @Bind.path('id') int heroID . Only the argument to Bind 's constructor must match the actual name of the path variable. This is valuable for other types of bindings, like headers, that may contain characters that aren't valid Dart variable names, e.g. X-API-Key.","title":"Request Binding"},{"location":"tutorial/getting_started/#the-more-you-know-multi-threading-and-application-state","text":"In this simple exercise, we used a constant list of heroes as our source of data. For a simple getting-your-feet-wet demo, this is fine. However, in a real application, you'd store this data in a database. That way you could add data to it and not risk losing it when the application was restarted. More generally, a web server should never hang on to data that can change. While previously just a best practice, stateless web servers are becoming a requirement with the prevalence of containerization and tools like Kubernetes. Liquidart makes it a bit easier to detect violations of this rule with its multi-threading strategy. When you run an Liquidart application, it creates multiple threads. Each of these threads has its own isolated heap in memory; meaning data that exists on one thread can't be accessed from other threads. In Dart, these isolated threads are called isolates. An instance of your application channel is created for each isolate. Each HTTP request is given to just one of the isolates to be handled. In a sense, your one application behaves the same as running your application on multiple servers behind a load balancer. (It also makes your application substantially faster.) If you are storing any data in your application, you'll find out really quickly. Why? A request that changes data will only change that data in one of your application's isolates. When you make a request to get that data again, its unlikely that you'll see the changes - another isolate with different data will probably handle that request.","title":"The More You Know: Multi-threading and Application State"},{"location":"tutorial/getting_started/#next-chapter-reading-from-a-database","text":"","title":"Next Chapter: Reading from a Database"},{"location":"tutorial/storing_data/","text":"3. Storing Data in a Database In the previous exercise, we loaded some heroes into the database our application reads from. Now, we will allow our application to store, delete and modify heroes in the database. Before we embark on this part of the journey, it's important that we understand how an HTTP API is intended to work. HTTP Resources and Methods The HTTP specification defines the concept of a resource . A resource can be anything - a hero, a bank account, a light switch in your home, a temperature sensor in Antarctica, etc. Some of these things are physical objects (the light switch), and some are digital - and they are all resources. An HTTP server application is an interface to these resources; a client requests that something be done with a resource, and the server finds a way to get it done. Resources are identified with a URI. A URI universally identifies a resource: it has the address of a server to connect to, and a path that identifies the resource on that server. When writing Liquidart applications, we don't care much about the server part of a URL - the internet figures out that part. What we do care about is the path of the URL - like /heroes . An application uses the URL path to determine which resource the request wants to work with. Right now, our application works with hero resources. A request with the path /heroes/1 wants to do something with an individual hero (that is identified by the number 1). A request with the path /heroes will act on the entire collection of heroes. These actions are primarily described by the request method (like GET, POST, OR DELETE). Each of these methods has a general meaning that describes an action that can be applied to a resource. For example, a GET /heroes means \"get me all of the hero resources\". The meaning for each of these methods are as follows: GET: returns a collection of some resource or an individual resource POST: inserts or appends a resource to a collection of some resource; a representation of the resource is in the request body PUT: replaces a resource with the contents of the request body (or in some cases, replaces the entire collection of some resource) DELETE: deletes a resource (or in some cases, deletes the entire collection of some resource) It turns out, we can create a lot of incredible behavior by just combining these methods and a request path. More importantly, by following these specifications, client applications can use generic libraries to access any HTTP API with very little effort. This allows us to create complex systems that are easily made available to a browser, mobile phone or any other internet-connected device. Inserting Data We'll start by adding behavior that allows for new heroes to be inserted into the database. Following our previous discussion, the HTTP request must take the form POST /heroes - we are appending a new hero to the collection of heroes. This request will contain the JSON representation of a hero in its body, for example: { \"name\": \"Master of Liquidarts\" } Our HeroesController will handle this operation. In general, a single endpoint controller should handle every operation on a resource collection and its individual resources. In heroes_controller.dart , add the following operation method: @Operation.post() Future<Response> createHero() async { final Map<String, dynamic> body = await request.body.decode(); final query = Query<Hero>(context) ..values.name = body['name'] as String; final insertedHero = await query.insert(); return Response.ok(insertedHero); } There are three important things happening here: this method decodes the JSON object from the request's body, constructs a query that inserts a new hero with the name in the JSON object, and then returns the newly inserted hero in the response. If the decoded body doesn't match the type of the variable or parameter it is being assigned to, a status code 400 exception is thrown. This means that decoding the body in this way checks that the body is the expected format and returns an error to the client on your behalf if it is not. For example, if someone posts a list of JSON objects, they will get a 400 Bad Request response because we expect a single JSON object in our method. An insertion query sets the properties of its values object. The values object is an instance of the type being inserted. Invoking insert on a query inserts a row with its values. A new hero, with its primary key set by the database, is returned and returned as the body of the response. The generated SQL for the above would be something like: INSERT INTO _Hero (name) VALUES ('Hero Name'); Column Attributes The id of a hero is automatically generated because of its @primaryKey annotation. This annotation is a Column that configures the id to be both a primary key and be 'auto-incrementing'. Auto-incremented columns values are generated automatically (1, 2, 3...). See the API reference for Column for column options. Re-run your application. In the browser application, click on Heroes near the top of the page. Then, enter a name into the Hero name: field and click Add . The new hero will appear. You can re-run the application and that hero will still be available, because it has been stored in the database on your machine. Assigning values one-by-one from a request body to a query is cumbersome. You can also auto-magically ingest a request body into a managed object and assign it to the values of a query: @Operation.post() Future<Response> createHero() async { final hero = Hero() ..read(await request.body.decode(), ignore: [\"id\"]); final query = Query<Hero>(context)..values = hero; final insertedHero = await query.insert(); return Response.ok(insertedHero); } The read method reads a Map<String, dynamic> into a managed object. Each key's value is assigned to the property of the same name. The ignore: optional parameter removes values for that key from the map before reading it. You can also reject or require keys in this way. If a request body contains a key that isn't declared as property of the managed object, a 400 status code exception is thrown. Sub-resources We mentioned that a single controller should handle every operation for a resource collection and its individual resources. Some resources are complex enough that they can have sub-resources. For example, an organization of heroes (like the X-Men or Fantastic Four) contains heroes, but it might also contain buildings and equipment owned by the organization. The heroes, buildings and equipment are sub-resources of an organization. Each sub-resource should have its own route and controller instead of trying to shove everything into a single route and controller. See the following code snippet for an example. @override Controller get entryPoint { return Router() ..route(\"/organizations/[:orgName]\") .link(() => OrganizationController()); ..route(\"/organizations/:orgName/heroes/[:heroID]\") .link(() => OrgHeroesController()); ..route(\"/organizations/:orgName/buildings/[:buildingID]\") .link(() => OrgBuildingController()); } Request and Response Bodies So far, we've largely glossed over how request and response bodies are handled, and now is a good time to dig in to this topic. Response Body Encoding When we create a response, we specify its status code and optionally its headers and body. For example, the following creates a response with a status code of 200 OK with an empty list body: Response.ok([]) The first argument to Response.ok is a body object . A body object is automatically encoded according to the contentType of its response. By default, the content type of a response is application/json - so by default, all of our response body objects are JSON-encoded in the response body. !!! \"Other Response Constructors\" The default constructor for a Response takes a status code, map of headers and a body object: Response(200, {}, \"body\") . There are many named constructors for Response, like Response.ok or Response.notFound . These constructors set the status code and expose parameters that are intended for that type of response. For example, a 200 OK response should have a body, so Response.ok has a required body object argument. See the API reference for Response for possible constructors and properties of a response. To change the format a body object is encoded into, you set the contentType of the response. For example, Response.ok([]) ..contentType = new ContentType(\"application\", \"xml\"); The default supported content types are JSON, application/x-www-form-urlencoded and all text/* types. To encode other content-types, you must register a Codec with CodecRegistry . A body object is only valid if the codec selected by the response's content-type can encode it. If it can't, an error will be thrown and a 500 Server Error response is sent instead. Types that implement Serializable may also be body objects. Objects that implement this type provide an asMap() method that converts their properties into a Map before being passed to the encoder. This Map must be encodable for the response's content-type codec. You may also provide a List of Serializable , for which the list of each object's asMap() is passed to the encoder. ManagedObject implements the Serializable interface, and therefore all managed objects (and lists of managed objects) can be body objects. Request Body Decoding Every Request has a body property of type RequestBody . A RequestBody decodes the contents of the request body into Dart objects that you use in your application. This decoding is performed by the Codec that is associated with the request's content-type. The decoded object is determined by the format of the data - for example, a JSON array decodes into a List , a JSON object into a Map . When you write code to decode a request body, you are also validating the request body is in the expected format. For example, your HeroesController invokes decode like this: Map<String, dynamic> body = await request.body.decode(); The decode method has a type argument that is inferred to be a Map<String, dynamic> . If the decoded body is not a Map , an exception is thrown that sends an appropriate error response to the client. You may also bind the body of a request to an operation method parameter. Let's bind a Hero instance to a request body in our HeroesController . Update the code in that file to the following: @Operation.post() Future<Response> createHero(@Bind.body(ignore: [\"id\"]) Hero inputHero) async { final query = Query<Hero>(context) ..values = inputHero; final insertedHero = await query.insert(); return Response.ok(insertedHero); } Values in the request body object are decoded into a Hero object - each key in the request body maps to a property of our Hero . For example, the value for the key 'name' is stored in the inputHero.name . If decoding the request body into a Hero instance fails for any reason, a 400 Bad Request response is sent and the operation method is not called. Binding Serializables A body can be bound to any type - a request will only succeed if the decoded body matches the expected type. When a Serializable subclass (or List<Serializable> ) is bound to a body, it enforces the body to be decoded into a Map<String, dynamic> (or a List<Map<String, dynamic>> ). All ManagedObjects implement Serializable , and therefore you may bind managed objects (and lists of such) using body binding. Re-run your heroes application. On http://aqueduct-tutorial.stablekernel.io , click on the Heroes button on the top of the screen. In the text field, enter a new hero name and click Add . You'll see your new hero added to the list! You can shutdown your application and run it again and you'll still be able to fetch your new hero. Query Construction Properties like values and where prevent errors by type and name checking columns with the analyzer. They're also great for speeding up writing code because your IDE will autocomplete property names. There is specific behavior a query uses to decide whether it should include a value from these two properties in the SQL it generates. Next Section: Writing Tests","title":"3. Storing Data in a Database"},{"location":"tutorial/storing_data/#3-storing-data-in-a-database","text":"In the previous exercise, we loaded some heroes into the database our application reads from. Now, we will allow our application to store, delete and modify heroes in the database. Before we embark on this part of the journey, it's important that we understand how an HTTP API is intended to work.","title":"3. Storing Data in a Database"},{"location":"tutorial/storing_data/#http-resources-and-methods","text":"The HTTP specification defines the concept of a resource . A resource can be anything - a hero, a bank account, a light switch in your home, a temperature sensor in Antarctica, etc. Some of these things are physical objects (the light switch), and some are digital - and they are all resources. An HTTP server application is an interface to these resources; a client requests that something be done with a resource, and the server finds a way to get it done. Resources are identified with a URI. A URI universally identifies a resource: it has the address of a server to connect to, and a path that identifies the resource on that server. When writing Liquidart applications, we don't care much about the server part of a URL - the internet figures out that part. What we do care about is the path of the URL - like /heroes . An application uses the URL path to determine which resource the request wants to work with. Right now, our application works with hero resources. A request with the path /heroes/1 wants to do something with an individual hero (that is identified by the number 1). A request with the path /heroes will act on the entire collection of heroes. These actions are primarily described by the request method (like GET, POST, OR DELETE). Each of these methods has a general meaning that describes an action that can be applied to a resource. For example, a GET /heroes means \"get me all of the hero resources\". The meaning for each of these methods are as follows: GET: returns a collection of some resource or an individual resource POST: inserts or appends a resource to a collection of some resource; a representation of the resource is in the request body PUT: replaces a resource with the contents of the request body (or in some cases, replaces the entire collection of some resource) DELETE: deletes a resource (or in some cases, deletes the entire collection of some resource) It turns out, we can create a lot of incredible behavior by just combining these methods and a request path. More importantly, by following these specifications, client applications can use generic libraries to access any HTTP API with very little effort. This allows us to create complex systems that are easily made available to a browser, mobile phone or any other internet-connected device.","title":"HTTP Resources and Methods"},{"location":"tutorial/storing_data/#inserting-data","text":"We'll start by adding behavior that allows for new heroes to be inserted into the database. Following our previous discussion, the HTTP request must take the form POST /heroes - we are appending a new hero to the collection of heroes. This request will contain the JSON representation of a hero in its body, for example: { \"name\": \"Master of Liquidarts\" } Our HeroesController will handle this operation. In general, a single endpoint controller should handle every operation on a resource collection and its individual resources. In heroes_controller.dart , add the following operation method: @Operation.post() Future<Response> createHero() async { final Map<String, dynamic> body = await request.body.decode(); final query = Query<Hero>(context) ..values.name = body['name'] as String; final insertedHero = await query.insert(); return Response.ok(insertedHero); } There are three important things happening here: this method decodes the JSON object from the request's body, constructs a query that inserts a new hero with the name in the JSON object, and then returns the newly inserted hero in the response. If the decoded body doesn't match the type of the variable or parameter it is being assigned to, a status code 400 exception is thrown. This means that decoding the body in this way checks that the body is the expected format and returns an error to the client on your behalf if it is not. For example, if someone posts a list of JSON objects, they will get a 400 Bad Request response because we expect a single JSON object in our method. An insertion query sets the properties of its values object. The values object is an instance of the type being inserted. Invoking insert on a query inserts a row with its values. A new hero, with its primary key set by the database, is returned and returned as the body of the response. The generated SQL for the above would be something like: INSERT INTO _Hero (name) VALUES ('Hero Name'); Column Attributes The id of a hero is automatically generated because of its @primaryKey annotation. This annotation is a Column that configures the id to be both a primary key and be 'auto-incrementing'. Auto-incremented columns values are generated automatically (1, 2, 3...). See the API reference for Column for column options. Re-run your application. In the browser application, click on Heroes near the top of the page. Then, enter a name into the Hero name: field and click Add . The new hero will appear. You can re-run the application and that hero will still be available, because it has been stored in the database on your machine. Assigning values one-by-one from a request body to a query is cumbersome. You can also auto-magically ingest a request body into a managed object and assign it to the values of a query: @Operation.post() Future<Response> createHero() async { final hero = Hero() ..read(await request.body.decode(), ignore: [\"id\"]); final query = Query<Hero>(context)..values = hero; final insertedHero = await query.insert(); return Response.ok(insertedHero); } The read method reads a Map<String, dynamic> into a managed object. Each key's value is assigned to the property of the same name. The ignore: optional parameter removes values for that key from the map before reading it. You can also reject or require keys in this way. If a request body contains a key that isn't declared as property of the managed object, a 400 status code exception is thrown. Sub-resources We mentioned that a single controller should handle every operation for a resource collection and its individual resources. Some resources are complex enough that they can have sub-resources. For example, an organization of heroes (like the X-Men or Fantastic Four) contains heroes, but it might also contain buildings and equipment owned by the organization. The heroes, buildings and equipment are sub-resources of an organization. Each sub-resource should have its own route and controller instead of trying to shove everything into a single route and controller. See the following code snippet for an example. @override Controller get entryPoint { return Router() ..route(\"/organizations/[:orgName]\") .link(() => OrganizationController()); ..route(\"/organizations/:orgName/heroes/[:heroID]\") .link(() => OrgHeroesController()); ..route(\"/organizations/:orgName/buildings/[:buildingID]\") .link(() => OrgBuildingController()); }","title":"Inserting Data"},{"location":"tutorial/storing_data/#request-and-response-bodies","text":"So far, we've largely glossed over how request and response bodies are handled, and now is a good time to dig in to this topic.","title":"Request and Response Bodies"},{"location":"tutorial/storing_data/#response-body-encoding","text":"When we create a response, we specify its status code and optionally its headers and body. For example, the following creates a response with a status code of 200 OK with an empty list body: Response.ok([]) The first argument to Response.ok is a body object . A body object is automatically encoded according to the contentType of its response. By default, the content type of a response is application/json - so by default, all of our response body objects are JSON-encoded in the response body. !!! \"Other Response Constructors\" The default constructor for a Response takes a status code, map of headers and a body object: Response(200, {}, \"body\") . There are many named constructors for Response, like Response.ok or Response.notFound . These constructors set the status code and expose parameters that are intended for that type of response. For example, a 200 OK response should have a body, so Response.ok has a required body object argument. See the API reference for Response for possible constructors and properties of a response. To change the format a body object is encoded into, you set the contentType of the response. For example, Response.ok([]) ..contentType = new ContentType(\"application\", \"xml\"); The default supported content types are JSON, application/x-www-form-urlencoded and all text/* types. To encode other content-types, you must register a Codec with CodecRegistry . A body object is only valid if the codec selected by the response's content-type can encode it. If it can't, an error will be thrown and a 500 Server Error response is sent instead. Types that implement Serializable may also be body objects. Objects that implement this type provide an asMap() method that converts their properties into a Map before being passed to the encoder. This Map must be encodable for the response's content-type codec. You may also provide a List of Serializable , for which the list of each object's asMap() is passed to the encoder. ManagedObject implements the Serializable interface, and therefore all managed objects (and lists of managed objects) can be body objects.","title":"Response Body Encoding"},{"location":"tutorial/storing_data/#request-body-decoding","text":"Every Request has a body property of type RequestBody . A RequestBody decodes the contents of the request body into Dart objects that you use in your application. This decoding is performed by the Codec that is associated with the request's content-type. The decoded object is determined by the format of the data - for example, a JSON array decodes into a List , a JSON object into a Map . When you write code to decode a request body, you are also validating the request body is in the expected format. For example, your HeroesController invokes decode like this: Map<String, dynamic> body = await request.body.decode(); The decode method has a type argument that is inferred to be a Map<String, dynamic> . If the decoded body is not a Map , an exception is thrown that sends an appropriate error response to the client. You may also bind the body of a request to an operation method parameter. Let's bind a Hero instance to a request body in our HeroesController . Update the code in that file to the following: @Operation.post() Future<Response> createHero(@Bind.body(ignore: [\"id\"]) Hero inputHero) async { final query = Query<Hero>(context) ..values = inputHero; final insertedHero = await query.insert(); return Response.ok(insertedHero); } Values in the request body object are decoded into a Hero object - each key in the request body maps to a property of our Hero . For example, the value for the key 'name' is stored in the inputHero.name . If decoding the request body into a Hero instance fails for any reason, a 400 Bad Request response is sent and the operation method is not called. Binding Serializables A body can be bound to any type - a request will only succeed if the decoded body matches the expected type. When a Serializable subclass (or List<Serializable> ) is bound to a body, it enforces the body to be decoded into a Map<String, dynamic> (or a List<Map<String, dynamic>> ). All ManagedObjects implement Serializable , and therefore you may bind managed objects (and lists of such) using body binding. Re-run your heroes application. On http://aqueduct-tutorial.stablekernel.io , click on the Heroes button on the top of the screen. In the text field, enter a new hero name and click Add . You'll see your new hero added to the list! You can shutdown your application and run it again and you'll still be able to fetch your new hero. Query Construction Properties like values and where prevent errors by type and name checking columns with the analyzer. They're also great for speeding up writing code because your IDE will autocomplete property names. There is specific behavior a query uses to decide whether it should include a value from these two properties in the SQL it generates.","title":"Request Body Decoding"},{"location":"tutorial/storing_data/#next-section-writing-tests","text":"","title":"Next Section: Writing Tests"},{"location":"tutorial/writing_tests/","text":"4. Configuration and Writing Tests We will continue to build on the last chapter's project, heroes , by writing automated tests for it. We will also set up configurable environments for our application. Application Configuration Right now, our application hardcodes its database connection information. This is bad because we want to use a different database when we're testing, running locally and running in production. It's also bad because we'd have to check our database password into version control. We can create a configuration file to store values like database connection information, and use a different configuration file for each environment. The heroes application needs to be able to configure the username, password, host port and name of the database it uses. Open the file config.yaml , which is empty, and enter the following key-value pairs: database: host: localhost port: 5432 username: heroes_user password: password databaseName: heroes These are the same values we used in our application channel. We'll want to replace the hardcoded values with whatever values are in this file. In lib/channel.dart , declare a new class at the bottom of the file: class HeroConfig extends Configuration { HeroConfig(String path): super.fromFile(File(path)); DatabaseConfiguration database; } A Configuration subclass declares the expected properties of a configuration file. HeroConfig has one property named database - this matches the name of our top-level key in config.yaml . A DatabaseConfiguration is a built-in configuration type that has properties for host , port , username , password and databaseName . We can load config.yaml into a HeroConfig because they have the same structure and all of the key names match the property names in our configuration types. Invalid Configuration If your configuration file and configuration object don't have a matching structure, an error will be thrown when your application starts and tell you which values are missing. Let's load config.yaml and use its values to set up our database connection by replacing the prepare method in lib/channel.dart : @override Future prepare() async { logger.onRecord.listen( (rec) => print(\"$rec ${rec.error ?? \"\"} ${rec.stackTrace ?? \"\"}\")); final config = HeroConfig(options.configurationFilePath); final dataModel = ManagedDataModel.fromCurrentMirrorSystem(); final persistentStore = PostgreSQLPersistentStore.fromConnectionInfo( config.database.username, config.database.password, config.database.host, config.database.port, config.database.databaseName); context = ManagedContext(dataModel, persistentStore); } When our application starts, our channel has access to an options property that has the command-line arguments that started the application. By default, the value of configurationFilePath is config.yaml (it corresponds to --config-path in liquidart serve ). When config.yaml is read, its values are read into a HeroConfig and are used to configure our database connection. Re-run your application and it'll work exactly the same as it did before - except now, we can substitute databases depending on how we run the application. Configuration Template You shouldn't check config.yaml into version control because it contains sensitive information. However, it is important to check in a configuration source file . A configuration source file has the same structure as HeroConfig , but it has values for your test environment - both locally and with continuous integration tools. It is also used as a template for your deployed configuration files. Sensitive Information Use a platform like Heroku or Kubernetes . You can store sensitive information in secured environment variables. You can substitute environment variables in a configuration file by using the variable's name with a $ prefix as a value, e.g. password: $DATABASE_PASSWORD . A configuration source file should be named config.src.yaml , and one currently exists as an empty file in your project. Enter the following configuration into this file: database: host: localhost port: 5432 username: dart password: dart databaseName: dart_test This file has the expected structure, but has different values for the database information (for a database that we will create shortly). In the next section, we'll use this configuration file to run our automated tests. Testing in Liquidart So far, we've tested our application by using a web application. This isn't a good way to test an application. A better way is to write automated test cases. An automated test case not only tests the code you are working on, but makes sure the code you've worked on in the past continues to work as you make changes. A good development practice is to configure TravisCI to run all of your tests for every code change. Because testing is so important, there is a package for writing Liquidart application tests. In this chapter, we will use this package to make sure our hero endpoints are working correctly. package:liquidart_test The package liquidart_test and test was already added to your pubspec.yaml file as a test dependency by the template generator. In all Dart applications, a test suite is a Dart script with a main function. In this function, the test function is called multiple times to register expectations. A test passes if all of your expectations are met. An example Dart test looks like this: import 'package:test/test.dart'; void main() { test(\"1+1 = 2\", () { // Expect that 1 + 1 = 2 expect(1 + 1, equals(2)); }); } Setting up your Development Environment In config.src.yaml , we target the database dart:dart@localhost:5432/dart_test . This is a 'special' database that is used by all Liquidart applications for automated testing (by default). When your application is tested, its tables are temporarily added to this database and then discarded after tests complete. This means that no data is stored in between test runs. Create this database by running psql and enter the following SQL: CREATE DATABASE dart_test; CREATE USER dart WITH createdb; ALTER USER dart WITH password 'dart'; GRANT all ON database dart_test TO dart; dart_test Database You only have to create this database once per machine, and in any continuous integration scripts. All of your Liquidart applications will use this database for automated testing. Fun fact - you can run multiple application's tests simultaneously using this database because the tables only exist for the database connection that created them. Writing Your First Test We will create a test suite to make sure that all hero endpoints return the right data, and make the right changes. Create a new file named test/hero_controller_test.dart . Test Files Names and Locations A test file must end in _test.dart and must be in the test/ directory of your project, or it won't be run. At the top of this file, import your application's test harness and enter the following main function: import 'harness/app.dart'; void main() { final harness = Harness()..install(); } A test harness is an object that starts and stops your application when running a test suite, as long as you call its install method. This harness can then send requests to your application, and you can expect that the response is correct. Add a test to the main function that makes sure we get back a 200 OK when we call GET /heroes : void main() { final harness = Harness()..install(); test(\"GET /heroes returns 200 OK\", () async { final response = await harness.agent.get(\"/heroes\"); expectResponse(response, 200); }); } A harness has an Agent that can send requests to the application it started. Methods like get and post take a path (and optionally headers and a body) and return a response object. This object is used in expectResponse to validate the status code and other values. Tests in Liquidart are written in this way: make a request, expect that the response is intended. Because our application makes database queries, we have to to upload our database schema to the test database before each test. Fortunately, this is something our test harness can also do. In test/harness/app.dart , mixin TestHarnessORMMixin and override two methods: class Harness extends TestHarness<HeroesChannel> with TestHarnessORMMixin { @override ManagedContext get context => channel.context; @override Future onSetUp() async { await resetData(); } } The mixin gives our harness the method resetData . This method deletes everything from the test database and uploads the schema in a pristine state. By calling this method in onSetUp , our test harness will reset data before each test. New Project Templates Using the -t command-line argument with liquidart create allows you to select a template. Templates like db and db_and_auth have a test harness that already mixes in TestHarnessORMMixin . Now, we can run this test by right-clicking on the main function in hero_controller_test.dart and selecting Run tests in ' hero_controller_test.dart '. A panel will appear that shows the results of your tests. You'll see a green checkmark next to the test in this panel to show that your test succeeded. If your test did not succeed, the reason will be printed to the console. If your test failed because of an error in your code, you will also be able to see the stack trace of the error. Running Tests You can also run all of your tests for an application by running pub run test from your project's directory. You can re-run a test with the green play button at the top right corner of the screen, or the keyboard shortcut associated with it (this shortcut varies depending on your installation). We should expect that more than just the status code is correct. Let's verify that the body is a list, where every element is an object that contains an id and name. Update your test: test(\"GET /heroes returns 200 OK\", () async { final response = await harness.agent.get(\"/heroes\"); expectResponse(response, 200, body: everyElement({ \"id\": greaterThan(0), \"name\": isString, })); }); This expectation ensures that the body is a list and that every element is an object with a id greater than 0 , and a name that is a string. When expecting a body value, the body is first decoded from its content-type before the expectation. In practice, this means that your JSON response body is deserialized into an object or list. Your expectations of the body are built from Dart objects like List and Object that deserialized from JSON. Matchers The function everyElement is a Matcher from package:matcher . There are many types of matchers for all kinds of scenarios, and package:liquidart_test includes Liquidart-specific matchers. See the liquidart_test API Reference for all Liquidart matchers. This test actually has an error that we will fix in it by using another matcher. Right now, this endpoint returns an empty list because there are no heroes in the database! Let's insert a hero before we make this request, and also expect that there is at least one element in the body. Make sure to import hero.dart at the top of the file! import 'package:heroes/model/hero.dart'; import 'harness/app.dart'; void main() { final harness = Harness()..install(); test(\"GET /heroes returns 200 OK\", () async { final query = Query<Hero>(harness.application.channel.context) ..values.name = \"Bob\"; await query.insert(); final response = await harness.agent.get(\"/heroes\"); expectResponse(response, 200, body: allOf([ hasLength(greaterThan(0)), everyElement({ \"id\": greaterThan(0), \"name\": isString, }) ])); }); } This test first inserts a hero named 'Bob' before getting all heroes. We compose a matcher where each element has to match the expected list, but also have a length greater than 0. Re-run your tests, and they should still pass. Writing More Tests Let's write a few more tests for when we POST /heroes. In the first test, we'll make a mistake on purpose to see how tests fail. Add the following test: test(\"POST /heroes returns 200 OK\", () async { final response = await harness.agent.post(\"/heroes\", body: { \"name\": \"Fred\" }); expectResponse(response, 200, body: { \"id\": greaterThan(0), \"name\": \"Bob\" }); }); This test creates a hero named 'Fred', but expects that the returned hero has the name 'Bob'. When we run the test, we see this test failure: Expected: --- HTTP Response --- - Status code must be 200 - Headers can be anything - Body after decoding must be: {'id': <a value greater than <0>>, 'name': 'Bob'} --------------------- Actual: TestResponse:<----------- - Status code is 200 - Headers are the following: - content-encoding: gzip - content-length: 42 - x-frame-options: SAMEORIGIN - content-type: application/json; charset=utf-8 - x-xss-protection: 1; mode=block - x-content-type-options: nosniff - server: liquidart/1 Decoded body is: {id: 1, name: Fred} ------------------------- > Which: the body differs for the following reasons: was 'Fred' instead of 'Bob' at location ['name'] The 'Expected' value tells us the response we expected - that it has a status code of 200, any headers and the body must have a certain structure. The 'Actual' value tells us what the actual response was - a 200 OK, a bunch of headers, and a body a hero named 'Fred'. 'Which' tells us exactly what went wrong - we were expecting 'Bob', not 'Fred'. Let's update our test to expect 'Fred'. test(\"POST /heroes returns 200 OK\", () async { final response = await harness.agent.post(\"/heroes\", body: { \"name\": \"Fred\" }); expectResponse(response, 200, body: { \"id\": greaterThan(0), \"name\": \"Fred\" }); }); We shouldn't just test success cases. Let's also expect that if we try and insert a hero with the same name, we get a 409 error response. test(\"POST /heroes returns 200 OK\", () async { await harness.agent.post(\"/heroes\", body: { \"name\": \"Fred\" }); final badResponse = await harness.agent.post(\"/heroes\", body: { \"name\": \"Fred\" }); expectResponse(badResponse, 409); }); In this test, we request two 'Fred' heroes be created, and the second request fails with a 409 because name is a unique property of a hero. Notice that the first request didn't fail, even though we had created a 'Fred' hero in the previous test - that's because we reset the database for each test in our harness. Next Section: Authentication and Authorization","title":"4. Configuration and Testing"},{"location":"tutorial/writing_tests/#4-configuration-and-writing-tests","text":"We will continue to build on the last chapter's project, heroes , by writing automated tests for it. We will also set up configurable environments for our application.","title":"4. Configuration and Writing Tests"},{"location":"tutorial/writing_tests/#application-configuration","text":"Right now, our application hardcodes its database connection information. This is bad because we want to use a different database when we're testing, running locally and running in production. It's also bad because we'd have to check our database password into version control. We can create a configuration file to store values like database connection information, and use a different configuration file for each environment. The heroes application needs to be able to configure the username, password, host port and name of the database it uses. Open the file config.yaml , which is empty, and enter the following key-value pairs: database: host: localhost port: 5432 username: heroes_user password: password databaseName: heroes These are the same values we used in our application channel. We'll want to replace the hardcoded values with whatever values are in this file. In lib/channel.dart , declare a new class at the bottom of the file: class HeroConfig extends Configuration { HeroConfig(String path): super.fromFile(File(path)); DatabaseConfiguration database; } A Configuration subclass declares the expected properties of a configuration file. HeroConfig has one property named database - this matches the name of our top-level key in config.yaml . A DatabaseConfiguration is a built-in configuration type that has properties for host , port , username , password and databaseName . We can load config.yaml into a HeroConfig because they have the same structure and all of the key names match the property names in our configuration types. Invalid Configuration If your configuration file and configuration object don't have a matching structure, an error will be thrown when your application starts and tell you which values are missing. Let's load config.yaml and use its values to set up our database connection by replacing the prepare method in lib/channel.dart : @override Future prepare() async { logger.onRecord.listen( (rec) => print(\"$rec ${rec.error ?? \"\"} ${rec.stackTrace ?? \"\"}\")); final config = HeroConfig(options.configurationFilePath); final dataModel = ManagedDataModel.fromCurrentMirrorSystem(); final persistentStore = PostgreSQLPersistentStore.fromConnectionInfo( config.database.username, config.database.password, config.database.host, config.database.port, config.database.databaseName); context = ManagedContext(dataModel, persistentStore); } When our application starts, our channel has access to an options property that has the command-line arguments that started the application. By default, the value of configurationFilePath is config.yaml (it corresponds to --config-path in liquidart serve ). When config.yaml is read, its values are read into a HeroConfig and are used to configure our database connection. Re-run your application and it'll work exactly the same as it did before - except now, we can substitute databases depending on how we run the application.","title":"Application Configuration"},{"location":"tutorial/writing_tests/#configuration-template","text":"You shouldn't check config.yaml into version control because it contains sensitive information. However, it is important to check in a configuration source file . A configuration source file has the same structure as HeroConfig , but it has values for your test environment - both locally and with continuous integration tools. It is also used as a template for your deployed configuration files. Sensitive Information Use a platform like Heroku or Kubernetes . You can store sensitive information in secured environment variables. You can substitute environment variables in a configuration file by using the variable's name with a $ prefix as a value, e.g. password: $DATABASE_PASSWORD . A configuration source file should be named config.src.yaml , and one currently exists as an empty file in your project. Enter the following configuration into this file: database: host: localhost port: 5432 username: dart password: dart databaseName: dart_test This file has the expected structure, but has different values for the database information (for a database that we will create shortly). In the next section, we'll use this configuration file to run our automated tests.","title":"Configuration Template"},{"location":"tutorial/writing_tests/#testing-in-liquidart","text":"So far, we've tested our application by using a web application. This isn't a good way to test an application. A better way is to write automated test cases. An automated test case not only tests the code you are working on, but makes sure the code you've worked on in the past continues to work as you make changes. A good development practice is to configure TravisCI to run all of your tests for every code change. Because testing is so important, there is a package for writing Liquidart application tests. In this chapter, we will use this package to make sure our hero endpoints are working correctly. package:liquidart_test The package liquidart_test and test was already added to your pubspec.yaml file as a test dependency by the template generator. In all Dart applications, a test suite is a Dart script with a main function. In this function, the test function is called multiple times to register expectations. A test passes if all of your expectations are met. An example Dart test looks like this: import 'package:test/test.dart'; void main() { test(\"1+1 = 2\", () { // Expect that 1 + 1 = 2 expect(1 + 1, equals(2)); }); }","title":"Testing in Liquidart"},{"location":"tutorial/writing_tests/#setting-up-your-development-environment","text":"In config.src.yaml , we target the database dart:dart@localhost:5432/dart_test . This is a 'special' database that is used by all Liquidart applications for automated testing (by default). When your application is tested, its tables are temporarily added to this database and then discarded after tests complete. This means that no data is stored in between test runs. Create this database by running psql and enter the following SQL: CREATE DATABASE dart_test; CREATE USER dart WITH createdb; ALTER USER dart WITH password 'dart'; GRANT all ON database dart_test TO dart; dart_test Database You only have to create this database once per machine, and in any continuous integration scripts. All of your Liquidart applications will use this database for automated testing. Fun fact - you can run multiple application's tests simultaneously using this database because the tables only exist for the database connection that created them.","title":"Setting up your Development Environment"},{"location":"tutorial/writing_tests/#writing-your-first-test","text":"We will create a test suite to make sure that all hero endpoints return the right data, and make the right changes. Create a new file named test/hero_controller_test.dart . Test Files Names and Locations A test file must end in _test.dart and must be in the test/ directory of your project, or it won't be run. At the top of this file, import your application's test harness and enter the following main function: import 'harness/app.dart'; void main() { final harness = Harness()..install(); } A test harness is an object that starts and stops your application when running a test suite, as long as you call its install method. This harness can then send requests to your application, and you can expect that the response is correct. Add a test to the main function that makes sure we get back a 200 OK when we call GET /heroes : void main() { final harness = Harness()..install(); test(\"GET /heroes returns 200 OK\", () async { final response = await harness.agent.get(\"/heroes\"); expectResponse(response, 200); }); } A harness has an Agent that can send requests to the application it started. Methods like get and post take a path (and optionally headers and a body) and return a response object. This object is used in expectResponse to validate the status code and other values. Tests in Liquidart are written in this way: make a request, expect that the response is intended. Because our application makes database queries, we have to to upload our database schema to the test database before each test. Fortunately, this is something our test harness can also do. In test/harness/app.dart , mixin TestHarnessORMMixin and override two methods: class Harness extends TestHarness<HeroesChannel> with TestHarnessORMMixin { @override ManagedContext get context => channel.context; @override Future onSetUp() async { await resetData(); } } The mixin gives our harness the method resetData . This method deletes everything from the test database and uploads the schema in a pristine state. By calling this method in onSetUp , our test harness will reset data before each test. New Project Templates Using the -t command-line argument with liquidart create allows you to select a template. Templates like db and db_and_auth have a test harness that already mixes in TestHarnessORMMixin . Now, we can run this test by right-clicking on the main function in hero_controller_test.dart and selecting Run tests in ' hero_controller_test.dart '. A panel will appear that shows the results of your tests. You'll see a green checkmark next to the test in this panel to show that your test succeeded. If your test did not succeed, the reason will be printed to the console. If your test failed because of an error in your code, you will also be able to see the stack trace of the error. Running Tests You can also run all of your tests for an application by running pub run test from your project's directory. You can re-run a test with the green play button at the top right corner of the screen, or the keyboard shortcut associated with it (this shortcut varies depending on your installation). We should expect that more than just the status code is correct. Let's verify that the body is a list, where every element is an object that contains an id and name. Update your test: test(\"GET /heroes returns 200 OK\", () async { final response = await harness.agent.get(\"/heroes\"); expectResponse(response, 200, body: everyElement({ \"id\": greaterThan(0), \"name\": isString, })); }); This expectation ensures that the body is a list and that every element is an object with a id greater than 0 , and a name that is a string. When expecting a body value, the body is first decoded from its content-type before the expectation. In practice, this means that your JSON response body is deserialized into an object or list. Your expectations of the body are built from Dart objects like List and Object that deserialized from JSON. Matchers The function everyElement is a Matcher from package:matcher . There are many types of matchers for all kinds of scenarios, and package:liquidart_test includes Liquidart-specific matchers. See the liquidart_test API Reference for all Liquidart matchers. This test actually has an error that we will fix in it by using another matcher. Right now, this endpoint returns an empty list because there are no heroes in the database! Let's insert a hero before we make this request, and also expect that there is at least one element in the body. Make sure to import hero.dart at the top of the file! import 'package:heroes/model/hero.dart'; import 'harness/app.dart'; void main() { final harness = Harness()..install(); test(\"GET /heroes returns 200 OK\", () async { final query = Query<Hero>(harness.application.channel.context) ..values.name = \"Bob\"; await query.insert(); final response = await harness.agent.get(\"/heroes\"); expectResponse(response, 200, body: allOf([ hasLength(greaterThan(0)), everyElement({ \"id\": greaterThan(0), \"name\": isString, }) ])); }); } This test first inserts a hero named 'Bob' before getting all heroes. We compose a matcher where each element has to match the expected list, but also have a length greater than 0. Re-run your tests, and they should still pass.","title":"Writing Your First Test"},{"location":"tutorial/writing_tests/#writing-more-tests","text":"Let's write a few more tests for when we POST /heroes. In the first test, we'll make a mistake on purpose to see how tests fail. Add the following test: test(\"POST /heroes returns 200 OK\", () async { final response = await harness.agent.post(\"/heroes\", body: { \"name\": \"Fred\" }); expectResponse(response, 200, body: { \"id\": greaterThan(0), \"name\": \"Bob\" }); }); This test creates a hero named 'Fred', but expects that the returned hero has the name 'Bob'. When we run the test, we see this test failure: Expected: --- HTTP Response --- - Status code must be 200 - Headers can be anything - Body after decoding must be: {'id': <a value greater than <0>>, 'name': 'Bob'} --------------------- Actual: TestResponse:<----------- - Status code is 200 - Headers are the following: - content-encoding: gzip - content-length: 42 - x-frame-options: SAMEORIGIN - content-type: application/json; charset=utf-8 - x-xss-protection: 1; mode=block - x-content-type-options: nosniff - server: liquidart/1 Decoded body is: {id: 1, name: Fred} ------------------------- > Which: the body differs for the following reasons: was 'Fred' instead of 'Bob' at location ['name'] The 'Expected' value tells us the response we expected - that it has a status code of 200, any headers and the body must have a certain structure. The 'Actual' value tells us what the actual response was - a 200 OK, a bunch of headers, and a body a hero named 'Fred'. 'Which' tells us exactly what went wrong - we were expecting 'Bob', not 'Fred'. Let's update our test to expect 'Fred'. test(\"POST /heroes returns 200 OK\", () async { final response = await harness.agent.post(\"/heroes\", body: { \"name\": \"Fred\" }); expectResponse(response, 200, body: { \"id\": greaterThan(0), \"name\": \"Fred\" }); }); We shouldn't just test success cases. Let's also expect that if we try and insert a hero with the same name, we get a 409 error response. test(\"POST /heroes returns 200 OK\", () async { await harness.agent.post(\"/heroes\", body: { \"name\": \"Fred\" }); final badResponse = await harness.agent.post(\"/heroes\", body: { \"name\": \"Fred\" }); expectResponse(badResponse, 409); }); In this test, we request two 'Fred' heroes be created, and the second request fails with a 409 because name is a unique property of a hero. Notice that the first request didn't fail, even though we had created a 'Fred' hero in the previous test - that's because we reset the database for each test in our harness.","title":"Writing More Tests"},{"location":"tutorial/writing_tests/#next-section-authentication-and-authorization","text":"","title":"Next Section: Authentication and Authorization"}]}